// ========================== v6.0 start =========================

import React, { useState, useEffect, useRef } from 'react';
import jsPDF from 'jspdf';
import { Download, Bold, Underline, ScanLine, FileUp, Save, Image as ImageIcon, Table as TableIcon } from 'lucide-react';

// --- CONFIGURATION ---
const SCALE = 2; // High Resolution
const A4_WIDTH = 595;
const A4_HEIGHT = 842;
const CANVAS_WIDTH = A4_WIDTH * SCALE;
const CANVAS_HEIGHT = A4_HEIGHT * SCALE;
const MARGIN_X = 50 * SCALE;
const MARGIN_Y = 60 * SCALE;

// --- TYPES ---
type SegmentType = 'text' | 'image' | 'table';

// Table Specific Types
type CellStyle = { text: string; color: string; isBold: boolean; align: string };
type TableRow = { cells: CellStyle[]; maxHeight?: number };
type TableData = { rows: TableRow[]; colWidths: number[]; totalWidth: number };

type TextSegment = {
  type: SegmentType;
  // Text Props
  text?: string;
  color?: string;
  isBold?: boolean;
  isUnderline?: boolean;
  width?: number;
  
  // Image Props
  src?: string;
  height?: number;

  // Table Props
  tableData?: TableData;
};

type PageData = {
  lines: TextSegment[][];
};

type ProjectFile = {
    version: string;
    htmlContent: string;
    settings: {
        skew: number;
        lineOpacity: number;
        scanEffect: boolean;
        fontSize: number;
    }
};

const App = () => {
  // --- STATE ---
  const [pages, setPages] = useState<PageData[]>([]);
  
  // Settings
  const [skewFactor, setSkewFactor] = useState(1.5);
  const [scanEffect, setScanEffect] = useState(false);
  const [lineOpacity, setLineOpacity] = useState(0.4); // Restored
  const [baseFontSize, setBaseFontSize] = useState(22);
  
  const [isProcessing, setIsProcessing] = useState(false);
  
  const editorRef = useRef<HTMLDivElement>(null);
  const canvasRefs = useRef<(HTMLCanvasElement | null)[]>([]);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Constants
  const CURRENT_FONT_SIZE = baseFontSize * SCALE;
  const CURRENT_LINE_HEIGHT = CURRENT_FONT_SIZE * 1.5;

  // --- 1. EDITOR COMMANDS ---
  const applyFormat = (command: string, value?: string) => {
    document.execCommand(command, false, value);
    editorRef.current?.focus();
    triggerParse(); 
  };

  const insertImage = (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
              const imgTag = `<img src="${event.target?.result}" style="max-width: 300px; display: block; margin: 10px 0;" />`;
              document.execCommand('insertHTML', false, imgTag);
              triggerParse();
          };
          reader.readAsDataURL(file);
      }
  };

  const insertTable = () => {
      // Basic structure for user to start with
      const tableHTML = `
        <table style="border-collapse: collapse; width: 100%; margin: 10px 0; border: 1px solid #000;">
            <tbody>
                <tr><td style="border: 1px solid #000; padding: 5px;">Head 1</td><td style="border: 1px solid #000; padding: 5px;">Head 2</td></tr>
                <tr><td style="border: 1px solid #000; padding: 5px;">Data 1</td><td style="border: 1px solid #000; padding: 5px;">Data 2</td></tr>
            </tbody>
        </table><p><br></p>
      `;
      document.execCommand('insertHTML', false, tableHTML);
      triggerParse();
  };

  // --- 2. PARSER ENGINE ---
  const triggerParse = () => {
    if (!editorRef.current) return;
    setIsProcessing(true);
    setTimeout(() => {
      parseContentToPages(editorRef.current!);
      setIsProcessing(false);
    }, 100);
  };

  const parseContentToPages = (root: HTMLElement) => {
    const ctx = document.createElement('canvas').getContext('2d')!;
    const segments: TextSegment[] = [];
    
    // --- HELPER: Measure Table ---
    const processTable = (tableEl: HTMLElement): TextSegment | null => {
        const rows = Array.from(tableEl.querySelectorAll('tr'));
        if (rows.length === 0) return null;

        const tableData: TableData = { rows: [], colWidths: [], totalWidth: 0 };
        const rawRows: TableRow[] = [];

        // 1. Extract Data
        rows.forEach(tr => {
            const cells = Array.from(tr.querySelectorAll('td, th'));
            const rowData: CellStyle[] = cells.map(cell => {
                const el = cell as HTMLElement;
                return {
                    text: el.innerText.trim(), // We use innerText to flatten content for table cells
                    color: el.style.color || '#000000',
                    isBold: el.tagName === 'TH' || el.style.fontWeight === 'bold',
                    align: el.style.textAlign || 'left'
                };
            });
            rawRows.push({ cells: rowData });
        });

        // 2. Calculate Column Widths (Dynamic Layout)
        const colCount = rawRows.reduce((max, r) => Math.max(max, r.cells.length), 0);
        const colWidths = new Array(colCount).fill(0);

        rawRows.forEach(row => {
            row.cells.forEach((cell, idx) => {
                ctx.font = `${cell.isBold ? 'bold' : 'normal'} ${CURRENT_FONT_SIZE}px 'Segoe Script'`;
                const width = ctx.measureText(cell.text).width + (20 * SCALE); // Padding
                if (width > colWidths[idx]) colWidths[idx] = width;
            });
        });

        // Normalize to fit page width
        const MAX_TABLE_WIDTH = CANVAS_WIDTH - (MARGIN_X * 2);
        const totalMeasuredWidth = colWidths.reduce((a, b) => a + b, 0);
        
        if (totalMeasuredWidth > MAX_TABLE_WIDTH) {
            // Shrink proportionally if too wide
            const ratio = MAX_TABLE_WIDTH / totalMeasuredWidth;
            for(let i=0; i<colWidths.length; i++) colWidths[i] *= ratio;
        }

        // Calculate Row Heights
        rawRows.forEach(row => {
             // For now, simple height based on text. Future: wrap text in cells.
             row.maxHeight = CURRENT_LINE_HEIGHT * 1.2; 
        });

        return {
            type: 'table',
            tableData: {
                rows: rawRows,
                colWidths: colWidths,
                totalWidth: colWidths.reduce((a, b) => a + b, 0)
            }
        };
    };

    // --- DOM TRAVERSAL ---
    const traverse = (node: Node, style: { color: string, isBold: boolean, isUnderline: boolean }, listContext: { type: string, index: number } | null) => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        const el = node as HTMLElement;
        const tagName = el.tagName;

        // TABLE HANDLING (Stop recursion, parse manually)
        if (tagName === 'TABLE') {
            const tableSeg = processTable(el);
            if (tableSeg) segments.push(tableSeg);
            return; // Don't parse children, we handled them
        }

        // IMAGE HANDLING
        if (tagName === 'IMG') {
            const imgEl = el as HTMLImageElement;
            segments.push({ 
                type: 'image', 
                src: imgEl.src, 
                width: imgEl.width * SCALE || 200 * SCALE, 
                height: imgEl.height * SCALE || 150 * SCALE 
            });
            return;
        }

        // BLOCK HANDLING
        const isBlock = ['DIV', 'P', 'BR', 'LI', 'H1', 'H2', 'TR'].includes(tagName);
        
        // LIST HANDLING
        let newListContext = listContext;
        if (tagName === 'UL') newListContext = { type: 'ul', index: 0 };
        if (tagName === 'OL') newListContext = { type: 'ol', index: 1 };
        
        // STYLE INHERITANCE
        let newColor = el.style.color || el.getAttribute('color') || style.color;
        const newBold = (tagName === 'B' || tagName === 'STRONG' || tagName === 'TH' || parseInt(el.style.fontWeight) > 600) || style.isBold;
        const newUnderline = (tagName === 'U' || el.style.textDecoration === 'underline') || style.isUnderline;

        // RENDER BULLETS
        if (tagName === 'LI' && listContext) {
            const bullet = listContext.type === 'ul' ? "• " : `${listContext.index}. `;
            segments.push({ type: 'text', text: bullet, color: newColor, isBold: true }); 
            if (listContext.type === 'ol') listContext.index++;
        }

        // RECURSE
        node.childNodes.forEach(child => traverse(child, { color: newColor, isBold: newBold, isUnderline: newUnderline }, newListContext));
        
        // NEWLINES FOR BLOCKS
        if (isBlock && tagName !== 'BR') {
           const lastSeg = segments[segments.length - 1];
           if (lastSeg && lastSeg.text !== '\n') segments.push({ type: 'text', text: '\n' });
        }
        if (tagName === 'BR') segments.push({ type: 'text', text: '\n' });

      } else if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent || "";
        if (text) segments.push({ type: 'text', text, color: style.color, isBold: style.isBold, isUnderline: style.isUnderline });
      }
    };

    traverse(root, { color: '#000000', isBold: false, isUnderline: false }, null);

    // --- PAGINATION ENGINE ---
    const finalPages: PageData[] = [];
    let currentLines: TextSegment[][] = [];
    let currentLine: TextSegment[] = [];
    let currentY = MARGIN_Y;
    let currentX = MARGIN_X;
    
    const flushLine = (forceHeight?: number) => {
        currentLines.push(currentLine);
        currentLine = [];
        currentX = MARGIN_X;
        currentY += forceHeight ? forceHeight + 10 : CURRENT_LINE_HEIGHT; 
        
        if (currentY > CANVAS_HEIGHT - MARGIN_Y) {
            finalPages.push({ lines: currentLines });
            currentLines = [];
            currentY = MARGIN_Y;
        }
    };

    segments.forEach(seg => {
      // 1. Newline
      if (seg.text === '\n') {
        flushLine();
        return;
      }

      // 2. Table or Image (Block Elements)
      if (seg.type === 'table' || seg.type === 'image') {
          if (currentLine.length > 0) flushLine();
          
          const height = seg.type === 'table' 
              ? (seg.tableData!.rows.length * (CURRENT_LINE_HEIGHT * 1.2)) + 20 // Approx Table Height
              : seg.height! + 20;

          // Check Overflow
          if (currentY + height > CANVAS_HEIGHT - MARGIN_Y) {
             finalPages.push({ lines: currentLines });
             currentLines = [];
             currentY = MARGIN_Y;
          }
          
          currentLines.push([seg]); // Add as standalone line
          currentY += height;
          return;
      }

      // 3. Inline Text
      if (seg.type === 'text') {
        const words = seg.text!.split(/(\s+)/); 
        words.forEach(word => {
            if (word === "") return;
            
            ctx.font = `${seg.isBold ? 'bold' : 'normal'} ${CURRENT_FONT_SIZE}px 'Segoe Script'`;
            const wordWidth = ctx.measureText(word).width;

            if (currentX + wordWidth > CANVAS_WIDTH - MARGIN_X) {
                flushLine();
            }

            currentLine.push({ ...seg, text: word, width: wordWidth });
            currentX += wordWidth;
        });
      }
    });

    if (currentLine.length > 0) flushLine();
    if (currentLines.length > 0) finalPages.push({ lines: currentLines });

    setPages(finalPages);
  };

  // --- 3. RENDERER ---
  useEffect(() => {
    pages.forEach((pageData, index) => {
      const canvas = canvasRefs.current[index];
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      // Clear
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      ctx.fillStyle = scanEffect ? "#f4f4f4" : "#fffdf0";
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      // Lines (Restored)
      if (lineOpacity > 0) {
          ctx.lineWidth = 1 * SCALE;
          ctx.strokeStyle = `rgba(100, 149, 237, ${lineOpacity})`; 
          for (let y = MARGIN_Y; y < CANVAS_HEIGHT; y += CURRENT_LINE_HEIGHT) {
            ctx.beginPath(); 
            ctx.moveTo(0, y); 
            ctx.bezierCurveTo(CANVAS_WIDTH/2, y + (scanEffect ? 2 : 0), CANVAS_WIDTH, y, CANVAS_WIDTH, y);
            ctx.stroke();
          }
          ctx.strokeStyle = `rgba(255, 100, 100, ${lineOpacity})`; 
          ctx.beginPath(); ctx.moveTo(MARGIN_X - (15*SCALE), 0); ctx.lineTo(MARGIN_X - (15*SCALE), CANVAS_HEIGHT); ctx.stroke();
      }

      // Render Loop
      let cursorY = MARGIN_Y;
      
      pageData.lines.forEach(line => {
        let cursorX = MARGIN_X;
        let maxLineHeight = CURRENT_LINE_HEIGHT;

        line.forEach(seg => {
           // --- RENDER IMAGE ---
           if (seg.type === 'image' && seg.src) {
               const img = new Image();
               img.src = seg.src;
               ctx.drawImage(img, cursorX, cursorY, seg.width!, seg.height!);
               // Tape
               ctx.fillStyle = "rgba(255,255,255,0.6)";
               ctx.fillRect(cursorX - 5, cursorY - 5, 30, 10);
               ctx.fillRect(cursorX + seg.width! - 25, cursorY - 5, 30, 10);
               maxLineHeight = seg.height! + 20;
           } 
           
           // --- RENDER TABLE (New Logic) ---
           else if (seg.type === 'table' && seg.tableData) {
               const { rows, colWidths } = seg.tableData;
               let tableY = cursorY;
               
               // Draw Outer Border? Optional. Let's draw loose grid.
               rows.forEach((row, rIdx) => {
                   let tableX = cursorX;
                   const rowHeight = row.maxHeight || CURRENT_LINE_HEIGHT;

                   // Draw Horizontal Line (Top of row)
                   ctx.beginPath();
                   ctx.strokeStyle = "#444";
                   ctx.lineWidth = 1.5;
                   ctx.moveTo(tableX, tableY);
                   ctx.lineTo(tableX + seg.tableData!.totalWidth, tableY);
                   ctx.stroke();

                   row.cells.forEach((cell, cIdx) => {
                       const cellWidth = colWidths[cIdx];
                       
                       // Draw Vertical Line (Left of cell)
                       ctx.beginPath();
                       ctx.moveTo(tableX, tableY);
                       ctx.lineTo(tableX, tableY + rowHeight);
                       ctx.stroke();

                       // Draw Text
                       ctx.font = `${cell.isBold ? 'bold' : 'normal'} ${CURRENT_FONT_SIZE}px 'Segoe Script', 'Caveat', cursive`;
                       ctx.fillStyle = cell.color;
                       
                       // Simple jitter
                       const rY = (Math.random() - 0.5) * (skewFactor * SCALE);
                       ctx.fillText(cell.text, tableX + (10*SCALE), tableY + (rowHeight*0.6) + rY);

                       tableX += cellWidth;
                   });

                   // Draw Final Vertical Line (Right)
                   ctx.beginPath();
                   ctx.moveTo(tableX, tableY);
                   ctx.lineTo(tableX, tableY + rowHeight);
                   ctx.stroke();

                   tableY += rowHeight;
               });
               
               // Draw Bottom Line
               ctx.beginPath();
               ctx.moveTo(cursorX, tableY);
               ctx.lineTo(cursorX + seg.tableData.totalWidth, tableY);
               ctx.stroke();

               maxLineHeight = (tableY - cursorY) + 20;
           }

           // --- RENDER TEXT ---
           else if (seg.type === 'text' && seg.text) {
              ctx.font = `${seg.isBold ? 'bold' : 'normal'} ${CURRENT_FONT_SIZE}px 'Segoe Script', 'Caveat', cursive`;
              ctx.fillStyle = seg.color || '#000';
              
              for (let i = 0; i < seg.text.length; i++) {
                const char = seg.text[i];
                const charWidth = ctx.measureText(char).width;
                
                const rY = (Math.random() - 0.5) * (skewFactor * SCALE);
                const rRot = (Math.random() - 0.5) * (skewFactor * 0.15);

                ctx.save();
                ctx.translate(cursorX + charWidth/2, cursorY + rY);
                ctx.rotate(rRot);
                ctx.fillText(char, -charWidth/2, 0);
                ctx.restore();
                
                // Underline
                if (seg.isUnderline) {
                    ctx.beginPath();
                    ctx.strokeStyle = seg.color || '#000';
                    ctx.lineWidth = 1.5;
                    ctx.moveTo(cursorX, cursorY + 5);
                    ctx.lineTo(cursorX + charWidth, cursorY + 5 + (Math.random()*2));
                    ctx.stroke();
                }

                cursorX += charWidth;
              }
           }
        });

        cursorY += maxLineHeight;
      });

      // Scan Noise
      if (scanEffect) {
          const grad = ctx.createLinearGradient(0, 0, 100 * SCALE, 0);
          grad.addColorStop(0, "rgba(0,0,0,0.12)");
          grad.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grad;
          ctx.fillRect(0,0, 100 * SCALE, CANVAS_HEIGHT);
      }
    });
  }, [pages, skewFactor, lineOpacity, scanEffect, baseFontSize]);

  // --- 4. EXPORT/IMPORT ---
  const saveProject = () => {
      const project: ProjectFile = {
          version: '3.0',
          htmlContent: editorRef.current?.innerHTML || '',
          settings: { skew: skewFactor, lineOpacity, scanEffect, fontSize: baseFontSize }
      };
      const blob = new Blob([JSON.stringify(project)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'assignment.azm';
      a.click();
  };

  const loadProject = (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
          try {
              const project = JSON.parse(event.target?.result as string) as ProjectFile;
              if (editorRef.current) editorRef.current.innerHTML = project.htmlContent;
              setSkewFactor(project.settings.skew);
              setLineOpacity(project.settings.lineOpacity);
              setScanEffect(project.settings.scanEffect);
              setBaseFontSize(project.settings.fontSize || 22);
              triggerParse();
          } catch (err) { alert("Invalid file"); }
      };
      reader.readAsText(file);
  };

  const downloadPDF = () => {
    const doc = new jsPDF('p', 'pt', [A4_WIDTH, A4_HEIGHT]);
    pages.forEach((_, i) => {
      const canvas = canvasRefs.current[i];
      if (canvas) {
        if (i > 0) doc.addPage();
        doc.addImage(canvas.toDataURL('image/jpeg', 0.8), 'JPEG', 0, 0, A4_WIDTH, A4_HEIGHT); 
      }
    });
    doc.save('assignment.pdf');
  };

  // Init
  useEffect(() => {
    if (editorRef.current) {
        editorRef.current.innerHTML = `<h3>Homework</h3><p>Here is the data table:</p>
        <table>
          <tr><th>Item</th><th>Cost</th><th>Notes</th></tr>
          <tr><td>Apple</td><td>$1.50</td><td>Fresh</td></tr>
          <tr><td>Banana</td><td>$0.80</td><td>Yellow</td></tr>
        </table>`;
        triggerParse();
    }
  }, []);

  return (
    <div className="min-h-screen bg-neutral-100 flex flex-col items-center p-6 font-sans">
      <header className="w-full max-w-6xl flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-slate-800 flex items-center gap-2">
           <span className="text-blue-600">✍️</span> AssignmentMaker <span className="text-xs bg-purple-100 text-purple-800 px-2 py-1 rounded">v6.0</span>
        </h1>
        <div className="flex gap-2">
            <button onClick={() => fileInputRef.current?.click()} className="bg-white border hover:bg-slate-50 text-slate-700 px-3 py-2 rounded-lg text-sm flex gap-2"><FileUp size={16}/> Import</button>
            <input type="file" ref={fileInputRef} onChange={loadProject} accept=".azm,.json" className="hidden" />
            <button onClick={saveProject} className="bg-white border hover:bg-slate-50 text-slate-700 px-3 py-2 rounded-lg text-sm flex gap-2"><Save size={16}/> Save</button>
            <button onClick={downloadPDF} className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg shadow text-sm flex gap-2"><Download size={16}/> Export PDF</button>
        </div>
      </header>

      <div className="w-full max-w-6xl flex gap-6 h-[85vh]">
        <div className="w-1/2 flex flex-col bg-white rounded-xl shadow-lg border border-slate-200">
          <div className="bg-slate-50 border-b p-3 flex gap-3 items-center flex-wrap select-none">
             <div className="flex bg-white border rounded-md overflow-hidden">
                {['#000000', '#000f55', '#cc0000', '#1a5c20'].map(c => (
                    <button key={c} onClick={() => applyFormat('foreColor', c)} className="w-7 h-7 hover:opacity-80" style={{backgroundColor: c}} />
                ))}
             </div>
             
             <div className="flex gap-1 items-center">
                <button onClick={() => applyFormat('bold')} className="p-1.5 hover:bg-slate-200 rounded" title="Bold"><Bold size={16}/></button>
                <button onClick={() => applyFormat('underline')} className="p-1.5 hover:bg-slate-200 rounded" title="Underline"><Underline size={16}/></button>
                <div className="w-px h-5 bg-slate-300 mx-1"></div>
                <button onClick={() => applyFormat('insertUnorderedList')} className="px-2 hover:bg-slate-200 rounded font-bold">•</button>
                <button onClick={() => applyFormat('insertOrderedList')} className="px-2 hover:bg-slate-200 rounded font-bold">1.</button>
                <button onClick={insertTable} className="p-1.5 hover:bg-slate-200 rounded" title="Table"><TableIcon size={16}/></button>
                <label className="p-1.5 hover:bg-slate-200 rounded cursor-pointer" title="Image"><ImageIcon size={16}/><input type="file" onChange={insertImage} className="hidden"/></label>
             </div>
             
             <div className="h-8 w-px bg-slate-300"></div>
             
             <div className="grid grid-cols-2 gap-x-3 gap-y-0 text-[10px] w-40">
                <label className="text-slate-500 font-semibold flex justify-between">Messy <span>{skewFactor}</span></label>
                <input type="range" min="0" max="3" step="0.5" value={skewFactor} onChange={(e) => setSkewFactor(parseFloat(e.target.value))} className="accent-blue-600 h-1"/>
                
                <label className="text-slate-500 font-semibold flex justify-between">Size <span>{baseFontSize}</span></label>
                <input type="range" min="14" max="32" step="1" value={baseFontSize} onChange={(e) => setBaseFontSize(parseInt(e.target.value))} className="accent-blue-600 h-1"/>

                <label className="text-slate-500 font-semibold flex justify-between col-span-2 mt-1">Lines Opacity</label>
                <input type="range" min="0" max="1" step="0.1" value={lineOpacity} onChange={(e) => setLineOpacity(parseFloat(e.target.value))} className="accent-blue-600 h-1 col-span-2"/>
             </div>

             <div className="h-8 w-px bg-slate-300"></div>
             <button onClick={() => setScanEffect(!scanEffect)} className={`flex items-center gap-1 px-2 py-1 rounded border text-xs ${scanEffect ? 'bg-indigo-100 border-indigo-400 text-indigo-700' : 'bg-white'}`}>
                <ScanLine size={14}/> {scanEffect ? 'On' : 'Off'}
             </button>
          </div>

          <div ref={editorRef} contentEditable onInput={triggerParse} className="flex-grow p-6 outline-none overflow-y-auto font-sans text-lg leading-relaxed text-slate-800"></div>
        </div>

        <div className="w-1/2 overflow-y-auto bg-slate-200 p-8 rounded-xl border border-slate-300 shadow-inner flex flex-col items-center gap-6">
           {pages.map((_, i) => (
             <div key={i} className="relative shadow-xl transition-all duration-300">
               <span className="absolute -left-8 top-2 text-slate-500 font-bold text-xs">Pg {i+1}</span>
               <canvas ref={el => canvasRefs.current[i] = el} width={CANVAS_WIDTH} height={CANVAS_HEIGHT} className="bg-white shadow-lg" style={{ width: '420px', height: 'auto' }} />
             </div>
           ))}
        </div>
      </div>
    </div>
  );
};

export default App;

// ========================== v6.0 end =========================

// ========================== v6.1 start =========================

//v6.1

import React, { useState, useEffect, useRef, useCallback } from 'react';
import jsPDF from 'jspdf';
import DOMPurify from 'dompurify';
import { Download, Bold, Underline, ScanLine, FileUp, Save, Image as ImageIcon, Table as TableIcon } from 'lucide-react';

// --- CONFIGURATION ---
const SCALE = 2; // High Resolution
const A4_WIDTH = 595;
const A4_HEIGHT = 842;
const CANVAS_WIDTH = A4_WIDTH * SCALE;
const CANVAS_HEIGHT = A4_HEIGHT * SCALE;
const MARGIN_X = 50 * SCALE;
const MARGIN_Y = 60 * SCALE;

// --- TYPES ---
type SegmentType = 'text' | 'image' | 'table';

// Table Specific Types
type CellStyle = { text: string; color: string; isBold: boolean; align: string };
type TableRow = { cells: CellStyle[]; maxHeight?: number };
type TableData = { rows: TableRow[]; colWidths: number[]; totalWidth: number };

type TextSegment = {
  type: SegmentType;
  // Text Props
  text?: string;
  color?: string;
  isBold?: boolean;
  isUnderline?: boolean;
  width?: number;
  
  // Image Props
  src?: string;
  height?: number;

  // Table Props
  tableData?: TableData;
};

type PageData = {
  lines: TextSegment[][];
};

type ProjectFile = {
    version: string;
    htmlContent: string;
    settings: {
        skew: number;
        lineOpacity: number;
        scanEffect: boolean;
        fontSize: number;
    }
};

const App = () => {
  // --- STATE ---
  const [pages, setPages] = useState<PageData[]>([]);
  
  // Settings
  const [skewFactor, setSkewFactor] = useState(1.5);
  const [scanEffect, setScanEffect] = useState(false);
  const [lineOpacity, setLineOpacity] = useState(0.4); // Restored
  const [baseFontSize, setBaseFontSize] = useState(22);
  
  const [isProcessing, setIsProcessing] = useState(false);
  
  const editorRef = useRef<HTMLDivElement>(null);
  const canvasRefs = useRef<(HTMLCanvasElement | null)[]>([]);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Constants
  const CURRENT_FONT_SIZE = baseFontSize * SCALE;
  const CURRENT_LINE_HEIGHT = CURRENT_FONT_SIZE * 1.5;

  // --- 1. EDITOR COMMANDS ---
  const applyFormat = (command: string, value?: string) => {
    document.execCommand(command, false, value);
    editorRef.current?.focus();
    triggerParse(); 
  };

  const insertImage = (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
              const imgTag = `<img src="${event.target?.result}" style="max-width: 300px; display: block; margin: 10px 0;" />`;
              document.execCommand('insertHTML', false, imgTag);
              triggerParse();
          };
          reader.readAsDataURL(file);
      }
  };

  const insertTable = () => {
      // Basic structure for user to start with
      const tableHTML = `
        <table style="border-collapse: collapse; width: 100%; margin: 10px 0; border: 1px solid #000;">
            <tbody>
                <tr><td style="border: 1px solid #000; padding: 5px;">Head 1</td><td style="border: 1px solid #000; padding: 5px;">Head 2</td></tr>
                <tr><td style="border: 1px solid #000; padding: 5px;">Data 1</td><td style="border: 1px solid #000; padding: 5px;">Data 2</td></tr>
            </tbody>
        </table><p><br></p>
      `;
      document.execCommand('insertHTML', false, tableHTML);
      triggerParse();
  };

  // --- 2. PARSER ENGINE ---
  const parseTimeoutRef = useRef<number | null>(null);
  const triggerParse = () => {
    if (!editorRef.current) return;
    setIsProcessing(true);
    if (parseTimeoutRef.current) {
      window.clearTimeout(parseTimeoutRef.current);
    }
    parseTimeoutRef.current = window.setTimeout(() => {
      parseContentToPages(editorRef.current!);
      setIsProcessing(false);
      parseTimeoutRef.current = null;
    }, 200);
  };

  useEffect(() => {
    return () => {
      if (parseTimeoutRef.current) window.clearTimeout(parseTimeoutRef.current);
    };
  }, []);

  const parseContentToPages = (root: HTMLElement) => {
    const ctx = document.createElement('canvas').getContext('2d')!;
    const segments: TextSegment[] = [];
    
    // --- HELPER: Measure Table ---
    const processTable = (tableEl: HTMLElement): TextSegment | null => {
        const rows = Array.from(tableEl.querySelectorAll('tr'));
        if (rows.length === 0) return null;

        const tableData: TableData = { rows: [], colWidths: [], totalWidth: 0 };
        const rawRows: TableRow[] = [];

        // 1. Extract Data
        rows.forEach(tr => {
            const cells = Array.from(tr.querySelectorAll('td, th'));
            const rowData: CellStyle[] = cells.map(cell => {
                const el = cell as HTMLElement;
                return {
                    text: el.innerText.trim(), // We use innerText to flatten content for table cells
                    color: el.style.color || '#000000',
                    isBold: el.tagName === 'TH' || el.style.fontWeight === 'bold',
                    align: el.style.textAlign || 'left'
                };
            });
            rawRows.push({ cells: rowData });
        });

        // 2. Calculate Column Widths (Dynamic Layout)
        const colCount = rawRows.reduce((max, r) => Math.max(max, r.cells.length), 0);
        const colWidths = new Array(colCount).fill(0);

        rawRows.forEach(row => {
            row.cells.forEach((cell, idx) => {
                ctx.font = `${cell.isBold ? 'bold' : 'normal'} ${CURRENT_FONT_SIZE}px 'Segoe Script'`;
                const width = ctx.measureText(cell.text).width + (20 * SCALE); // Padding
                if (width > colWidths[idx]) colWidths[idx] = width;
            });
        });

        // Normalize to fit page width
        const MAX_TABLE_WIDTH = CANVAS_WIDTH - (MARGIN_X * 2);
        const totalMeasuredWidth = colWidths.reduce((a, b) => a + b, 0);
        
        if (totalMeasuredWidth > MAX_TABLE_WIDTH) {
            // Shrink proportionally if too wide
            const ratio = MAX_TABLE_WIDTH / totalMeasuredWidth;
            for(let i=0; i<colWidths.length; i++) colWidths[i] *= ratio;
        }

        // Calculate Row Heights
        rawRows.forEach(row => {
             // For now, simple height based on text. Future: wrap text in cells.
             row.maxHeight = CURRENT_LINE_HEIGHT * 1.2; 
        });

        return {
            type: 'table',
            tableData: {
                rows: rawRows,
                colWidths: colWidths,
                totalWidth: colWidths.reduce((a, b) => a + b, 0)
            }
        };
    };

    // --- DOM TRAVERSAL ---
    const traverse = (node: Node, style: { color: string, isBold: boolean, isUnderline: boolean }, listContext: { type: string, index: number } | null) => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        const el = node as HTMLElement;
        const tagName = el.tagName;

        // TABLE HANDLING (Stop recursion, parse manually)
        if (tagName === 'TABLE') {
            const tableSeg = processTable(el);
            if (tableSeg) segments.push(tableSeg);
            return; // Don't parse children, we handled them
        }

        // IMAGE HANDLING
        if (tagName === 'IMG') {
            const imgEl = el as HTMLImageElement;
            segments.push({ 
                type: 'image', 
                src: imgEl.src, 
                width: imgEl.width * SCALE || 200 * SCALE, 
                height: imgEl.height * SCALE || 150 * SCALE 
            });
            return;
        }

        // BLOCK HANDLING
        const isBlock = ['DIV', 'P', 'BR', 'LI', 'H1', 'H2', 'TR'].includes(tagName);
        
        // LIST HANDLING
        let newListContext = listContext;
        if (tagName === 'UL') newListContext = { type: 'ul', index: 0 };
        if (tagName === 'OL') newListContext = { type: 'ol', index: 1 };
        
        // STYLE INHERITANCE
        let newColor = el.style.color || el.getAttribute('color') || style.color;
        const newBold = (tagName === 'B' || tagName === 'STRONG' || tagName === 'TH' || parseInt(el.style.fontWeight) > 600) || style.isBold;
        const newUnderline = (tagName === 'U' || el.style.textDecoration === 'underline') || style.isUnderline;

        // RENDER BULLETS
        if (tagName === 'LI' && listContext) {
            const bullet = listContext.type === 'ul' ? "• " : `${listContext.index}. `;
            segments.push({ type: 'text', text: bullet, color: newColor, isBold: true }); 
            if (listContext.type === 'ol') listContext.index++;
        }

        // RECURSE
        node.childNodes.forEach(child => traverse(child, { color: newColor, isBold: newBold, isUnderline: newUnderline }, newListContext));
        
        // NEWLINES FOR BLOCKS
        if (isBlock && tagName !== 'BR') {
           const lastSeg = segments[segments.length - 1];
           if (lastSeg && lastSeg.text !== '\n') segments.push({ type: 'text', text: '\n' });
        }
        if (tagName === 'BR') segments.push({ type: 'text', text: '\n' });

      } else if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent || "";
        if (text) segments.push({ type: 'text', text, color: style.color, isBold: style.isBold, isUnderline: style.isUnderline });
      }
    };

    traverse(root, { color: '#000000', isBold: false, isUnderline: false }, null);

    // --- PAGINATION ENGINE ---
    const finalPages: PageData[] = [];
    let currentLines: TextSegment[][] = [];
    let currentLine: TextSegment[] = [];
    let currentY = MARGIN_Y;
    let currentX = MARGIN_X;
    
    const flushLine = (forceHeight?: number) => {
        currentLines.push(currentLine);
        currentLine = [];
        currentX = MARGIN_X;
        currentY += forceHeight ? forceHeight + 10 : CURRENT_LINE_HEIGHT; 
        
        if (currentY > CANVAS_HEIGHT - MARGIN_Y) {
            finalPages.push({ lines: currentLines });
            currentLines = [];
            currentY = MARGIN_Y;
        }
    };

    segments.forEach(seg => {
      // 1. Newline
      if (seg.text === '\n') {
        flushLine();
        return;
      }

      // 2. Table or Image (Block Elements)
      if (seg.type === 'table' || seg.type === 'image') {
          if (currentLine.length > 0) flushLine();
          
          const height = seg.type === 'table' 
              ? (seg.tableData!.rows.length * (CURRENT_LINE_HEIGHT * 1.2)) + 20 // Approx Table Height
              : seg.height! + 20;

          // Check Overflow
          if (currentY + height > CANVAS_HEIGHT - MARGIN_Y) {
             finalPages.push({ lines: currentLines });
             currentLines = [];
             currentY = MARGIN_Y;
          }
          
          currentLines.push([seg]); // Add as standalone line
          currentY += height;
          return;
      }

      // 3. Inline Text
      if (seg.type === 'text') {
        const words = seg.text!.split(/(\s+)/); 
        words.forEach(word => {
            if (word === "") return;
            
            ctx.font = `${seg.isBold ? 'bold' : 'normal'} ${CURRENT_FONT_SIZE}px 'Segoe Script'`;
            const wordWidth = ctx.measureText(word).width;

            if (currentX + wordWidth > CANVAS_WIDTH - MARGIN_X) {
                flushLine();
            }

            currentLine.push({ ...seg, text: word, width: wordWidth });
            currentX += wordWidth;
        });
      }
    });

    if (currentLine.length > 0) flushLine();
    if (currentLines.length > 0) finalPages.push({ lines: currentLines });

    setPages(finalPages);
  };

  // --- 3. RENDERER ---
  useEffect(() => {
    pages.forEach((pageData, index) => {
      const canvas = canvasRefs.current[index];
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      // Deterministic RNG per page for reproducible exports
      const mulberry32 = (seed: number) => {
        return () => {
          let t = seed += 0x6D2B79F5;
          t = Math.imul(t ^ (t >>> 15), t | 1);
          t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      };
      const rng = mulberry32(index + baseFontSize + Math.floor(skewFactor * 100));

      // Clear
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      ctx.fillStyle = scanEffect ? "#f4f4f4" : "#fffdf0";
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      // Lines (Restored)
      if (lineOpacity > 0) {
          ctx.lineWidth = 1 * SCALE;
          ctx.strokeStyle = `rgba(100, 149, 237, ${lineOpacity})`; 
          for (let y = MARGIN_Y; y < CANVAS_HEIGHT; y += CURRENT_LINE_HEIGHT) {
            ctx.beginPath(); 
            ctx.moveTo(0, y); 
            ctx.bezierCurveTo(CANVAS_WIDTH/2, y + (scanEffect ? 2 : 0), CANVAS_WIDTH, y, CANVAS_WIDTH, y);
            ctx.stroke();
          }
          ctx.strokeStyle = `rgba(255, 100, 100, ${lineOpacity})`; 
          ctx.beginPath(); ctx.moveTo(MARGIN_X - (15*SCALE), 0); ctx.lineTo(MARGIN_X - (15*SCALE), CANVAS_HEIGHT); ctx.stroke();
      }

      // Render Loop
      let cursorY = MARGIN_Y;
      
      pageData.lines.forEach(line => {
        let cursorX = MARGIN_X;
        let maxLineHeight = CURRENT_LINE_HEIGHT;

        line.forEach(seg => {
           // --- RENDER IMAGE ---
           if (seg.type === 'image' && seg.src) {
               const img = new Image();
               img.crossOrigin = 'anonymous';
               const drawW = seg.width || (150 * SCALE);
               const drawH = seg.height || (100 * SCALE);
               img.onload = () => {
                 ctx.drawImage(img, cursorX, cursorY, drawW, drawH);
                 // Tape
                 ctx.fillStyle = "rgba(255,255,255,0.6)";
                 ctx.fillRect(cursorX - 5, cursorY - 5, 30, 10);
                 ctx.fillRect(cursorX + drawW - 25, cursorY - 5, 30, 10);
               };
               img.onerror = () => {
                 // Placeholder for failed images
                 ctx.fillStyle = '#eee';
                 ctx.fillRect(cursorX, cursorY, drawW, drawH);
                 ctx.fillStyle = '#666';
                 ctx.fillText('Image', cursorX + 10, cursorY + 20);
               };
               img.src = seg.src;
               maxLineHeight = drawH + 20;
           } 
           
           // --- RENDER TABLE (New Logic) ---
           else if (seg.type === 'table' && seg.tableData) {
               const { rows, colWidths } = seg.tableData;
               let tableY = cursorY;
               
               // Draw Outer Border? Optional. Let's draw loose grid.
               rows.forEach((row, rIdx) => {
                   let tableX = cursorX;
                   const rowHeight = row.maxHeight || CURRENT_LINE_HEIGHT;

                   // Draw Horizontal Line (Top of row)
                   ctx.beginPath();
                   ctx.strokeStyle = "#444";
                   ctx.lineWidth = 1.5;
                   ctx.moveTo(tableX, tableY);
                   ctx.lineTo(tableX + seg.tableData!.totalWidth, tableY);
                   ctx.stroke();

                   row.cells.forEach((cell, cIdx) => {
                       const cellWidth = colWidths[cIdx];
                       
                       // Draw Vertical Line (Left of cell)
                       ctx.beginPath();
                       ctx.moveTo(tableX, tableY);
                       ctx.lineTo(tableX, tableY + rowHeight);
                       ctx.stroke();

                       // Draw Text
                       ctx.font = `${cell.isBold ? 'bold' : 'normal'} ${CURRENT_FONT_SIZE}px 'Segoe Script', 'Caveat', cursive`;
                       ctx.fillStyle = cell.color;
                       
                       // Simple jitter (deterministic)
                       const rY = (rng() - 0.5) * (skewFactor * SCALE);
                       ctx.fillText(cell.text, tableX + (10*SCALE), tableY + (rowHeight*0.6) + rY);

                       tableX += cellWidth;
                   });

                   // Draw Final Vertical Line (Right)
                   ctx.beginPath();
                   ctx.moveTo(tableX, tableY);
                   ctx.lineTo(tableX, tableY + rowHeight);
                   ctx.stroke();

                   tableY += rowHeight;
               });
               
               // Draw Bottom Line
               ctx.beginPath();
               ctx.moveTo(cursorX, tableY);
               ctx.lineTo(cursorX + seg.tableData.totalWidth, tableY);
               ctx.stroke();

               maxLineHeight = (tableY - cursorY) + 20;
           }

           // --- RENDER TEXT ---
           else if (seg.type === 'text' && seg.text) {
              ctx.font = `${seg.isBold ? 'bold' : 'normal'} ${CURRENT_FONT_SIZE}px 'Segoe Script', 'Caveat', cursive`;
              ctx.fillStyle = seg.color || '#000';
              
              for (let i = 0; i < seg.text.length; i++) {
                const char = seg.text[i];
                const charWidth = ctx.measureText(char).width;
                
                const rY = (rng() - 0.5) * (skewFactor * SCALE);
                const rRot = (rng() - 0.5) * (skewFactor * 0.15);

                ctx.save();
                ctx.translate(cursorX + charWidth/2, cursorY + rY);
                ctx.rotate(rRot);
                ctx.fillText(char, -charWidth/2, 0);
                ctx.restore();
                
                // Underline
                if (seg.isUnderline) {
                    ctx.beginPath();
                    ctx.strokeStyle = seg.color || '#000';
                    ctx.lineWidth = 1.5;
                    ctx.moveTo(cursorX, cursorY + 5);
                    ctx.lineTo(cursorX + charWidth, cursorY + 5 + (rng()*2));
                    ctx.stroke();
                }

                cursorX += charWidth;
              }
           }
        });

        cursorY += maxLineHeight;
      });

      // Scan Noise
      if (scanEffect) {
          const grad = ctx.createLinearGradient(0, 0, 100 * SCALE, 0);
          grad.addColorStop(0, "rgba(0,0,0,0.12)");
          grad.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grad;
          ctx.fillRect(0,0, 100 * SCALE, CANVAS_HEIGHT);
      }
    });
  }, [pages, skewFactor, lineOpacity, scanEffect, baseFontSize]);

  // --- 4. EXPORT/IMPORT ---
  const saveProject = () => {
      const project: ProjectFile = {
          version: '3.0',
          htmlContent: editorRef.current?.innerHTML || '',
          settings: { skew: skewFactor, lineOpacity, scanEffect, fontSize: baseFontSize }
      };
      const blob = new Blob([JSON.stringify(project)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'assignment.azm';
      a.click();
  };

  const loadProject = (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
          try {
              const project = JSON.parse(event.target?.result as string) as ProjectFile;
              if (editorRef.current) editorRef.current.innerHTML = DOMPurify.sanitize(project.htmlContent);
              setSkewFactor(project.settings.skew);
              setLineOpacity(project.settings.lineOpacity);
              setScanEffect(project.settings.scanEffect);
              setBaseFontSize(project.settings.fontSize || 22);
              triggerParse();
          } catch (err) { alert("Invalid file"); }
      };
      reader.readAsText(file);
  };

  const downloadPDF = () => {
    const doc = new jsPDF('p', 'pt', [A4_WIDTH, A4_HEIGHT]);
    pages.forEach((_, i) => {
      const canvas = canvasRefs.current[i];
      if (canvas) {
        if (i > 0) doc.addPage();
        doc.addImage(canvas.toDataURL('image/jpeg', 0.8), 'JPEG', 0, 0, A4_WIDTH, A4_HEIGHT); 
      }
    });
    doc.save('assignment.pdf');
  };

  // Init
  useEffect(() => {
    if (editorRef.current) {
        editorRef.current.innerHTML = `<h3>Homework</h3><p>Here is the data table:</p>
        <table>
          <tr><th>Item</th><th>Cost</th><th>Notes</th></tr>
          <tr><td>Apple</td><td>$1.50</td><td>Fresh</td></tr>
          <tr><td>Banana</td><td>$0.80</td><td>Yellow</td></tr>
        </table>`;
        triggerParse();
    }
  }, []);

  return (
    <div className="min-h-screen bg-neutral-100 flex flex-col items-center p-6 font-sans">
      <header className="w-full max-w-6xl flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-slate-800 flex items-center gap-2">
           <span className="text-blue-600">✍️</span> AssignmentMaker <span className="text-xs bg-purple-100 text-purple-800 px-2 py-1 rounded">v6.0</span>
        </h1>
        <div className="flex gap-2">
            <button aria-label="Import project" onClick={() => fileInputRef.current?.click()} className="bg-white border hover:bg-slate-50 text-slate-700 px-3 py-2 rounded-lg text-sm flex gap-2"><FileUp size={16}/> Import</button>
            <input type="file" ref={fileInputRef} onChange={loadProject} accept=".azm,.json" className="hidden" />
            <button aria-label="Save project" onClick={saveProject} className="bg-white border hover:bg-slate-50 text-slate-700 px-3 py-2 rounded-lg text-sm flex gap-2"><Save size={16}/> Save</button>
            <button aria-label="Export PDF" onClick={downloadPDF} className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg shadow text-sm flex gap-2"><Download size={16}/> Export PDF</button>
        </div>
      </header>

      <div className="w-full max-w-6xl flex gap-6 h-[85vh]">
        <div className="w-1/2 flex flex-col bg-white rounded-xl shadow-lg border border-slate-200">
          <div className="bg-slate-50 border-b p-3 flex gap-3 items-center flex-wrap select-none">
             <div className="flex bg-white border rounded-md overflow-hidden">
                {['#000000', '#000f55', '#cc0000', '#1a5c20'].map(c => (
                    <button key={c} onClick={() => applyFormat('foreColor', c)} className="w-7 h-7 hover:opacity-80" style={{backgroundColor: c}} />
                ))}
             </div>
             
             <div className="flex gap-1 items-center">
                <button aria-label="Bold" onClick={() => applyFormat('bold')} className="p-1.5 hover:bg-slate-200 rounded" title="Bold"><Bold size={16}/></button>
                <button aria-label="Underline" onClick={() => applyFormat('underline')} className="p-1.5 hover:bg-slate-200 rounded" title="Underline"><Underline size={16}/></button>
                <div className="w-px h-5 bg-slate-300 mx-1"></div>
                <button aria-label="Bulleted list" onClick={() => applyFormat('insertUnorderedList')} className="px-2 hover:bg-slate-200 rounded font-bold">•</button>
                <button aria-label="Numbered list" onClick={() => applyFormat('insertOrderedList')} className="px-2 hover:bg-slate-200 rounded font-bold">1.</button>
                <button aria-label="Insert table" onClick={insertTable} className="p-1.5 hover:bg-slate-200 rounded" title="Table"><TableIcon size={16}/></button>
                <label aria-label="Insert image" className="p-1.5 hover:bg-slate-200 rounded cursor-pointer" title="Image"><ImageIcon size={16}/><input type="file" onChange={insertImage} className="hidden"/></label>
             </div>
             
             <div className="h-8 w-px bg-slate-300"></div>
             
             <div className="grid grid-cols-2 gap-x-3 gap-y-0 text-[10px] w-40">
                <label className="text-slate-500 font-semibold flex justify-between">Messy <span>{skewFactor}</span></label>
                <input type="range" min="0" max="3" step="0.5" value={skewFactor} onChange={(e) => setSkewFactor(parseFloat(e.target.value))} className="accent-blue-600 h-1"/>
                
                <label className="text-slate-500 font-semibold flex justify-between">Size <span>{baseFontSize}</span></label>
                <input type="range" min="14" max="32" step="1" value={baseFontSize} onChange={(e) => setBaseFontSize(parseInt(e.target.value))} className="accent-blue-600 h-1"/>

                <label className="text-slate-500 font-semibold flex justify-between col-span-2 mt-1">Lines Opacity</label>
                <input type="range" min="0" max="1" step="0.1" value={lineOpacity} onChange={(e) => setLineOpacity(parseFloat(e.target.value))} className="accent-blue-600 h-1 col-span-2"/>
             </div>

             <div className="h-8 w-px bg-slate-300"></div>
             <button onClick={() => setScanEffect(!scanEffect)} className={`flex items-center gap-1 px-2 py-1 rounded border text-xs ${scanEffect ? 'bg-indigo-100 border-indigo-400 text-indigo-700' : 'bg-white'}`}>
                <ScanLine size={14}/> {scanEffect ? 'On' : 'Off'}
             </button>
          </div>

          <div ref={editorRef} contentEditable onInput={triggerParse} role="textbox" aria-label="Assignment editor" aria-multiline="true" className="flex-grow p-6 outline-none overflow-y-auto font-sans text-lg leading-relaxed text-slate-800"></div>
        </div>

        <div className="w-1/2 overflow-y-auto bg-slate-200 p-8 rounded-xl border border-slate-300 shadow-inner flex flex-col items-center gap-6">
           {pages.map((_, i) => (
             <div key={i} className="relative shadow-xl transition-all duration-300">
               <span className="absolute -left-8 top-2 text-slate-500 font-bold text-xs">Pg {i+1}</span>
               <canvas ref={el => canvasRefs.current[i] = el} width={CANVAS_WIDTH} height={CANVAS_HEIGHT} className="bg-white shadow-lg" style={{ width: '420px', height: 'auto' }} />
             </div>
           ))}
        </div>
      </div>
    </div>
  );
};

export default App;

// ========================== v6.1 end =========================

// ========================== v6.12 start =========================
// ========================== v6.12 start =========================

import React, { useState, useEffect, useRef } from 'react';
import jsPDF from 'jspdf';
import DOMPurify from 'dompurify';
import { Download, Bold, Underline, ScanLine, FileUp, Save, Image as ImageIcon, Table as TableIcon, Grid3X3, AlignJustify } from 'lucide-react';

// --- CONFIGURATION ---
const SCALE = 2; // High Resolution (2x)
const A4_WIDTH = 595;
const A4_HEIGHT = 842;
const CANVAS_WIDTH = A4_WIDTH * SCALE;
const CANVAS_HEIGHT = A4_HEIGHT * SCALE;
const MARGIN_X = 50 * SCALE;
const MARGIN_Y = 60 * SCALE;

// --- TYPES ---
type SegmentType = 'text' | 'image' | 'table';
type PaperType = 'lined' | 'grid' | 'blank';

// Table Specific Types
type CellStyle = { text: string; color: string; isBold: boolean; align: string };
type TableRow = { cells: CellStyle[]; maxHeight?: number };
type TableData = { rows: TableRow[]; colWidths: number[]; totalWidth: number };

type TextSegment = {
  type: SegmentType;
  // Text Props
  text?: string;
  color?: string;
  isBold?: boolean;
  isUnderline?: boolean;
  width?: number;
  
  // Image Props
  src?: string;
  height?: number;

  // Table Props
  tableData?: TableData;
};

type PageData = {
  lines: TextSegment[][];
};

type ProjectFile = {
    version: string;
    htmlContent: string;
    settings: {
        skew: number;
        lineOpacity: number;
        scanEffect: boolean;
        fontSize: number;
        paperType: PaperType;
    }
};

const App = () => {
  // --- STATE ---
  const [pages, setPages] = useState<PageData[]>([]);
  
  // Settings
  const [skewFactor, setSkewFactor] = useState(1.5);
  const [scanEffect, setScanEffect] = useState(false);
  const [lineOpacity, setLineOpacity] = useState(0.4); 
  const [baseFontSize, setBaseFontSize] = useState(22);
  const [paperType, setPaperType] = useState<PaperType>('lined');
  
  const [isProcessing, setIsProcessing] = useState(false);
  
  const editorRef = useRef<HTMLDivElement>(null);
  const canvasRefs = useRef<(HTMLCanvasElement | null)[]>([]);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const parseTimeoutRef = useRef<number | null>(null);

  // Constants
  const CURRENT_FONT_SIZE = baseFontSize * SCALE;
  const CURRENT_LINE_HEIGHT = CURRENT_FONT_SIZE * 1.5;
  const FONT_STACK = "'Segoe Script', 'Caveat', cursive"; // Cross-platform fallback

  // --- 1. EDITOR COMMANDS ---
  const applyFormat = (command: string, value?: string) => {
    document.execCommand(command, false, value);
    editorRef.current?.focus();
    triggerParse(); 
  };

  const insertImage = (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
              const imgTag = `<img src="${event.target?.result}" style="max-width: 300px; display: block; margin: 10px 0;" />`;
              document.execCommand('insertHTML', false, imgTag);
              triggerParse();
          };
          reader.readAsDataURL(file);
      }
  };

  const insertTable = () => {
      const tableHTML = `
        <table style="border-collapse: collapse; width: 100%; margin: 10px 0; border: 1px solid #000;">
            <tbody>
                <tr><td style="border: 1px solid #000; padding: 5px;">Head 1</td><td style="border: 1px solid #000; padding: 5px;">Head 2</td></tr>
                <tr><td style="border: 1px solid #000; padding: 5px;">Data 1</td><td style="border: 1px solid #000; padding: 5px;">Data 2</td></tr>
            </tbody>
        </table><p><br></p>
      `;
      document.execCommand('insertHTML', false, tableHTML);
      triggerParse();
  };

  // --- 2. PARSER ENGINE (Debounced) ---
  const triggerParse = () => {
    if (!editorRef.current) return;
    setIsProcessing(true);
    
    if (parseTimeoutRef.current) {
      window.clearTimeout(parseTimeoutRef.current);
    }

    parseTimeoutRef.current = window.setTimeout(() => {
      parseContentToPages(editorRef.current!);
      setIsProcessing(false);
      parseTimeoutRef.current = null;
    }, 300); // 300ms debounce
  };

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (parseTimeoutRef.current) window.clearTimeout(parseTimeoutRef.current);
    };
  }, []);

  const parseContentToPages = (root: HTMLElement) => {
    const ctx = document.createElement('canvas').getContext('2d')!;
    const segments: TextSegment[] = [];
    
    // --- HELPER: Measure Table ---
    const processTable = (tableEl: HTMLElement): TextSegment | null => {
        const rows = Array.from(tableEl.querySelectorAll('tr'));
        if (rows.length === 0) return null;

        const tableData: TableData = { rows: [], colWidths: [], totalWidth: 0 };
        const rawRows: TableRow[] = [];

        // 1. Extract Data
        rows.forEach(tr => {
            const cells = Array.from(tr.querySelectorAll('td, th'));
            const rowData: CellStyle[] = cells.map(cell => {
                const el = cell as HTMLElement;
                return {
                    text: el.innerText.trim(), 
                    color: el.style.color || '#000000',
                    isBold: el.tagName === 'TH' || el.style.fontWeight === 'bold',
                    align: el.style.textAlign || 'left'
                };
            });
            rawRows.push({ cells: rowData });
        });

        // 2. Calculate Column Widths
        const colCount = rawRows.reduce((max, r) => Math.max(max, r.cells.length), 0);
        const colWidths = new Array(colCount).fill(0);

        rawRows.forEach(row => {
            row.cells.forEach((cell, idx) => {
                ctx.font = `${cell.isBold ? 'bold' : 'normal'} ${CURRENT_FONT_SIZE}px ${FONT_STACK}`;
                const width = ctx.measureText(cell.text).width + (20 * SCALE);
                if (width > colWidths[idx]) colWidths[idx] = width;
            });
        });

        const MAX_TABLE_WIDTH = CANVAS_WIDTH - (MARGIN_X * 2);
        const totalMeasuredWidth = colWidths.reduce((a, b) => a + b, 0);
        
        if (totalMeasuredWidth > MAX_TABLE_WIDTH) {
            const ratio = MAX_TABLE_WIDTH / totalMeasuredWidth;
            for(let i=0; i<colWidths.length; i++) colWidths[i] *= ratio;
        }

        rawRows.forEach(row => {
             row.maxHeight = CURRENT_LINE_HEIGHT * 1.2; 
        });

        return {
            type: 'table',
            tableData: {
                rows: rawRows,
                colWidths: colWidths,
                totalWidth: colWidths.reduce((a, b) => a + b, 0)
            }
        };
    };

    // --- DOM TRAVERSAL ---
    const traverse = (node: Node, style: { color: string, isBold: boolean, isUnderline: boolean }, listContext: { type: string, index: number } | null) => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        const el = node as HTMLElement;
        const tagName = el.tagName;

        if (tagName === 'TABLE') {
            const tableSeg = processTable(el);
            if (tableSeg) segments.push(tableSeg);
            return; 
        }

        if (tagName === 'IMG') {
            const imgEl = el as HTMLImageElement;
            segments.push({ 
                type: 'image', 
                src: imgEl.src, 
                width: imgEl.width * SCALE || 200 * SCALE, 
                height: imgEl.height * SCALE || 150 * SCALE 
            });
            return;
        }

        const isBlock = ['DIV', 'P', 'BR', 'LI', 'H1', 'H2', 'TR'].includes(tagName);
        
        let newListContext = listContext;
        if (tagName === 'UL') newListContext = { type: 'ul', index: 0 };
        if (tagName === 'OL') newListContext = { type: 'ol', index: 1 };
        
        let newColor = el.style.color || el.getAttribute('color') || style.color;
        const newBold = (tagName === 'B' || tagName === 'STRONG' || tagName === 'TH' || parseInt(el.style.fontWeight) > 600) || style.isBold;
        const newUnderline = (tagName === 'U' || el.style.textDecoration === 'underline') || style.isUnderline;

        if (tagName === 'LI' && listContext) {
            const bullet = listContext.type === 'ul' ? "• " : `${listContext.index}. `;
            segments.push({ type: 'text', text: bullet, color: newColor, isBold: true }); 
            if (listContext.type === 'ol') listContext.index++;
        }

        node.childNodes.forEach(child => traverse(child, { color: newColor, isBold: newBold, isUnderline: newUnderline }, newListContext));
        
        if (isBlock && tagName !== 'BR') {
           const lastSeg = segments[segments.length - 1];
           if (lastSeg && lastSeg.text !== '\n') segments.push({ type: 'text', text: '\n' });
        }
        if (tagName === 'BR') segments.push({ type: 'text', text: '\n' });

      } else if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent || "";
        if (text) segments.push({ type: 'text', text, color: style.color, isBold: style.isBold, isUnderline: style.isUnderline });
      }
    };

    traverse(root, { color: '#000000', isBold: false, isUnderline: false }, null);

    // --- PAGINATION ENGINE ---
    const finalPages: PageData[] = [];
    let currentLines: TextSegment[][] = [];
    let currentLine: TextSegment[] = [];
    let currentY = MARGIN_Y;
    let currentX = MARGIN_X;
    
    const flushLine = (forceHeight?: number) => {
        currentLines.push(currentLine);
        currentLine = [];
        currentX = MARGIN_X;
        currentY += forceHeight ? forceHeight + 10 : CURRENT_LINE_HEIGHT; 
        
        if (currentY > CANVAS_HEIGHT - MARGIN_Y) {
            finalPages.push({ lines: currentLines });
            currentLines = [];
            currentY = MARGIN_Y;
        }
    };

    segments.forEach(seg => {
      if (seg.text === '\n') {
        flushLine();
        return;
      }

      if (seg.type === 'table' || seg.type === 'image') {
          if (currentLine.length > 0) flushLine();
          
          const height = seg.type === 'table' 
              ? (seg.tableData!.rows.length * (CURRENT_LINE_HEIGHT * 1.2)) + 20 
              : seg.height! + 20;

          if (currentY + height > CANVAS_HEIGHT - MARGIN_Y) {
             finalPages.push({ lines: currentLines });
             currentLines = [];
             currentY = MARGIN_Y;
          }
          
          currentLines.push([seg]); 
          currentY += height;
          return;
      }

      if (seg.type === 'text') {
        const words = seg.text!.split(/(\s+)/); 
        words.forEach(word => {
            if (word === "") return;
            
            ctx.font = `${seg.isBold ? 'bold' : 'normal'} ${CURRENT_FONT_SIZE}px ${FONT_STACK}`;
            const wordWidth = ctx.measureText(word).width;

            if (currentX + wordWidth > CANVAS_WIDTH - MARGIN_X) {
                flushLine();
            }

            currentLine.push({ ...seg, text: word, width: wordWidth });
            currentX += wordWidth;
        });
      }
    });

    if (currentLine.length > 0) flushLine();
    if (currentLines.length > 0) finalPages.push({ lines: currentLines });

    setPages(finalPages);
  };

  // --- 3. RENDERER ---
  useEffect(() => {
    pages.forEach((pageData, index) => {
      const canvas = canvasRefs.current[index];
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      // Seeded RNG to stop text from "dancing" on re-renders
      const mulberry32 = (seed: number) => {
        return () => {
          let t = seed += 0x6D2B79F5;
          t = Math.imul(t ^ (t >>> 15), t | 1);
          t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      };
      const rng = mulberry32(index + baseFontSize + Math.floor(skewFactor * 100));

      // Clear
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      ctx.fillStyle = scanEffect ? "#f4f4f4" : "#fffdf0";
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      // --- PAPER BACKGROUND (Lined vs Grid) ---
      if (lineOpacity > 0) {
          ctx.strokeStyle = `rgba(100, 149, 237, ${lineOpacity})`; 
          ctx.lineWidth = 1 * SCALE;
          
          if (paperType === 'grid') {
            // Draw Grid
            ctx.lineWidth = 0.5 * SCALE;
            const gridSize = 25 * SCALE;
            for (let x = MARGIN_X; x < CANVAS_WIDTH; x += gridSize) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, CANVAS_HEIGHT); ctx.stroke();
            }
            for (let y = 0; y < CANVAS_HEIGHT; y += gridSize) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(CANVAS_WIDTH, y); ctx.stroke();
            }
          } else if (paperType === 'lined') {
            // Draw Lined
            for (let y = MARGIN_Y; y < CANVAS_HEIGHT; y += CURRENT_LINE_HEIGHT) {
                ctx.beginPath(); 
                ctx.moveTo(0, y); 
                // Slight curve for realism
                ctx.bezierCurveTo(CANVAS_WIDTH/2, y + (scanEffect ? 2 : 0), CANVAS_WIDTH, y, CANVAS_WIDTH, y);
                ctx.stroke();
            }
            // Red Margin
            ctx.strokeStyle = `rgba(255, 100, 100, ${lineOpacity})`; 
            ctx.beginPath(); ctx.moveTo(MARGIN_X - (15*SCALE), 0); ctx.lineTo(MARGIN_X - (15*SCALE), CANVAS_HEIGHT); ctx.stroke();
          }
      }

      // Render Content
      let cursorY = MARGIN_Y;
      
      pageData.lines.forEach(line => {
        let cursorX = MARGIN_X;
        let maxLineHeight = CURRENT_LINE_HEIGHT;

        line.forEach(seg => {
           // --- IMAGE ---
           if (seg.type === 'image' && seg.src) {
               const img = new Image();
               img.crossOrigin = 'anonymous';
               const drawW = seg.width || (150 * SCALE);
               const drawH = seg.height || (100 * SCALE);
               img.onload = () => {
                 ctx.drawImage(img, cursorX, cursorY, drawW, drawH);
                 // Tape Effect
                 ctx.fillStyle = "rgba(255,255,255,0.6)";
                 ctx.fillRect(cursorX - 5, cursorY - 5, 30, 10);
                 ctx.fillRect(cursorX + drawW - 25, cursorY - 5, 30, 10);
               };
               img.src = seg.src;
               maxLineHeight = drawH + 20;
           } 
           
           // --- TABLE ---
           else if (seg.type === 'table' && seg.tableData) {
               const { rows, colWidths } = seg.tableData;
               let tableY = cursorY;
               
               rows.forEach((row, rIdx) => {
                   let tableX = cursorX;
                   const rowHeight = row.maxHeight || CURRENT_LINE_HEIGHT;

                   // Top Line
                   ctx.beginPath(); ctx.strokeStyle = "#444"; ctx.lineWidth = 1.5;
                   ctx.moveTo(tableX, tableY); ctx.lineTo(tableX + seg.tableData!.totalWidth, tableY); ctx.stroke();

                   row.cells.forEach((cell, cIdx) => {
                       const cellWidth = colWidths[cIdx];
                       
                       // Left Line
                       ctx.beginPath(); ctx.moveTo(tableX, tableY); ctx.lineTo(tableX, tableY + rowHeight); ctx.stroke();

                       // Text
                       ctx.font = `${cell.isBold ? 'bold' : 'normal'} ${CURRENT_FONT_SIZE}px ${FONT_STACK}`;
                       ctx.fillStyle = cell.color;
                       
                       const rY = (rng() - 0.5) * (skewFactor * SCALE);
                       ctx.fillText(cell.text, tableX + (10*SCALE), tableY + (rowHeight*0.6) + rY);

                       tableX += cellWidth;
                   });

                   // Right Line
                   ctx.beginPath(); ctx.moveTo(tableX, tableY); ctx.lineTo(tableX, tableY + rowHeight); ctx.stroke();
                   tableY += rowHeight;
               });
               
               // Bottom Line
               ctx.beginPath(); ctx.moveTo(cursorX, tableY); ctx.lineTo(cursorX + seg.tableData.totalWidth, tableY); ctx.stroke();
               maxLineHeight = (tableY - cursorY) + 20;
           }

           // --- TEXT ---
           else if (seg.type === 'text' && seg.text) {
              ctx.font = `${seg.isBold ? 'bold' : 'normal'} ${CURRENT_FONT_SIZE}px ${FONT_STACK}`;
              ctx.fillStyle = seg.color || '#000';
              
              for (let i = 0; i < seg.text.length; i++) {
                const char = seg.text[i];
                const charWidth = ctx.measureText(char).width;
                
                const rY = (rng() - 0.5) * (skewFactor * SCALE);
                const rRot = (rng() - 0.5) * (skewFactor * 0.15);

                ctx.save();
                ctx.translate(cursorX + charWidth/2, cursorY + rY);
                ctx.rotate(rRot);
                ctx.fillText(char, -charWidth/2, 0);
                ctx.restore();
                
                if (seg.isUnderline) {
                    ctx.beginPath();
                    ctx.strokeStyle = seg.color || '#000';
                    ctx.lineWidth = 1.5;
                    ctx.moveTo(cursorX, cursorY + 5);
                    ctx.lineTo(cursorX + charWidth, cursorY + 5 + (rng()*2));
                    ctx.stroke();
                }

                cursorX += charWidth;
              }
           }
        });

        cursorY += maxLineHeight;
      });

      // Scan Noise
      if (scanEffect) {
          const grad = ctx.createLinearGradient(0, 0, 100 * SCALE, 0);
          grad.addColorStop(0, "rgba(0,0,0,0.12)");
          grad.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grad;
          ctx.fillRect(0,0, 100 * SCALE, CANVAS_HEIGHT);
      }
    });
  }, [pages, skewFactor, lineOpacity, scanEffect, baseFontSize, paperType]);

  // --- 4. EXPORT/IMPORT ---
  const saveProject = () => {
      const project: ProjectFile = {
          version: '3.0',
          htmlContent: editorRef.current?.innerHTML || '',
          settings: { skew: skewFactor, lineOpacity, scanEffect, fontSize: baseFontSize, paperType }
      };
      const blob = new Blob([JSON.stringify(project)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'assignment.azm';
      a.click();
  };

  const loadProject = (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
          try {
              const project = JSON.parse(event.target?.result as string) as ProjectFile;
              // SECURITY: Sanitize HTML before inserting!
              if (editorRef.current) editorRef.current.innerHTML = DOMPurify.sanitize(project.htmlContent);
              
              setSkewFactor(project.settings.skew);
              setLineOpacity(project.settings.lineOpacity);
              setScanEffect(project.settings.scanEffect);
              setBaseFontSize(project.settings.fontSize || 22);
              setPaperType(project.settings.paperType || 'lined');
              triggerParse();
          } catch (err) { alert("Invalid file"); }
      };
      reader.readAsText(file);
  };

  const downloadPDF = () => {
    const doc = new jsPDF('p', 'pt', [A4_WIDTH, A4_HEIGHT]);
    pages.forEach((_, i) => {
      const canvas = canvasRefs.current[i];
      if (canvas) {
        if (i > 0) doc.addPage();
        doc.addImage(canvas.toDataURL('image/jpeg', 0.8), 'JPEG', 0, 0, A4_WIDTH, A4_HEIGHT); 
      }
    });
    doc.save('assignment.pdf');
  };

  // Init
  useEffect(() => {
    if (editorRef.current) {
        editorRef.current.innerHTML = `<h3>Homework</h3><p>Data Table:</p>
        <table>
          <tr><th>Item</th><th>Cost</th></tr>
          <tr><td>Apple</td><td>$1.50</td></tr>
          <tr><td>Banana</td><td>$0.80</td></tr>
        </table>`;
        triggerParse();
    }
  }, []);

  return (
    <div className="min-h-screen bg-neutral-100 flex flex-col items-center p-6 font-sans">
      <header className="w-full max-w-6xl flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-slate-800 flex items-center gap-2">
           <span className="text-blue-600">✍️</span> AssignmentMaker 
           <span className="text-xs bg-purple-100 text-purple-800 px-2 py-1 rounded">v6.1</span>
           {isProcessing && <span className="text-xs text-blue-500 animate-pulse ml-2">Processing...</span>}
        </h1>
        <div className="flex gap-2">
            <button aria-label="Import" onClick={() => fileInputRef.current?.click()} className="bg-white border hover:bg-slate-50 text-slate-700 px-3 py-2 rounded-lg text-sm flex gap-2"><FileUp size={16}/> Import</button>
            <input type="file" ref={fileInputRef} onChange={loadProject} accept=".azm,.json" className="hidden" />
            <button aria-label="Save" onClick={saveProject} className="bg-white border hover:bg-slate-50 text-slate-700 px-3 py-2 rounded-lg text-sm flex gap-2"><Save size={16}/> Save</button>
            <button aria-label="Export PDF" onClick={downloadPDF} className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg shadow text-sm flex gap-2"><Download size={16}/> PDF</button>
        </div>
      </header>

      <div className="w-full max-w-6xl flex gap-6 h-[85vh]">
        <div className="w-1/2 flex flex-col bg-white rounded-xl shadow-lg border border-slate-200">
          <div className="bg-slate-50 border-b p-3 flex gap-3 items-center flex-wrap select-none">
             <div className="flex bg-white border rounded-md overflow-hidden">
                {['#000000', '#000f55', '#cc0000', '#1a5c20'].map(c => (
                    <button key={c} onClick={() => applyFormat('foreColor', c)} className="w-7 h-7 hover:opacity-80" style={{backgroundColor: c}} />
                ))}
             </div>
             
             <div className="flex gap-1 items-center">
                <button aria-label="Bold" onClick={() => applyFormat('bold')} className="p-1.5 hover:bg-slate-200 rounded" title="Bold"><Bold size={16}/></button>
                <button aria-label="Underline" onClick={() => applyFormat('underline')} className="p-1.5 hover:bg-slate-200 rounded" title="Underline"><Underline size={16}/></button>
                <div className="w-px h-5 bg-slate-300 mx-1"></div>
                <button onClick={() => applyFormat('insertUnorderedList')} className="px-2 hover:bg-slate-200 rounded font-bold">•</button>
                <button onClick={() => applyFormat('insertOrderedList')} className="px-2 hover:bg-slate-200 rounded font-bold">1.</button>
                <button onClick={insertTable} className="p-1.5 hover:bg-slate-200 rounded" title="Table"><TableIcon size={16}/></button>
                <label className="p-1.5 hover:bg-slate-200 rounded cursor-pointer" title="Image"><ImageIcon size={16}/><input type="file" onChange={insertImage} className="hidden"/></label>
             </div>
             
             <div className="h-8 w-px bg-slate-300"></div>
             
             <div className="grid grid-cols-2 gap-x-3 gap-y-0 text-[10px] w-40">
                <label className="text-slate-500 font-semibold flex justify-between">Messy <span>{skewFactor}</span></label>
                <input type="range" min="0" max="3" step="0.5" value={skewFactor} onChange={(e) => setSkewFactor(parseFloat(e.target.value))} className="accent-blue-600 h-1"/>
                
                <label className="text-slate-500 font-semibold flex justify-between">Size <span>{baseFontSize}</span></label>
                <input type="range" min="14" max="32" step="1" value={baseFontSize} onChange={(e) => setBaseFontSize(parseInt(e.target.value))} className="accent-blue-600 h-1"/>

                <label className="text-slate-500 font-semibold flex justify-between col-span-2 mt-1">Lines Opacity</label>
                <input type="range" min="0" max="1" step="0.1" value={lineOpacity} onChange={(e) => setLineOpacity(parseFloat(e.target.value))} className="accent-blue-600 h-1 col-span-2"/>
             </div>

             <div className="h-8 w-px bg-slate-300"></div>
             
             {/* Paper Toggle */}
             <button onClick={() => setPaperType(prev => prev === 'lined' ? 'grid' : prev === 'grid' ? 'blank' : 'lined')} 
                     className="flex items-center gap-1 px-2 py-1 rounded border text-xs bg-white hover:bg-slate-50" title="Switch Paper Type">
                 {paperType === 'lined' ? <AlignJustify size={14}/> : paperType === 'grid' ? <Grid3X3 size={14}/> : '⬜'}
             </button>

             <button onClick={() => setScanEffect(!scanEffect)} className={`flex items-center gap-1 px-2 py-1 rounded border text-xs ${scanEffect ? 'bg-indigo-100 border-indigo-400 text-indigo-700' : 'bg-white'}`}>
                <ScanLine size={14}/> {scanEffect ? 'Scan' : 'Scan'}
             </button>
          </div>

          <div ref={editorRef} contentEditable onInput={triggerParse} role="textbox" aria-label="Assignment editor" className="flex-grow p-6 outline-none overflow-y-auto font-sans text-lg leading-relaxed text-slate-800"></div>
        </div>

        <div className="w-1/2 overflow-y-auto bg-slate-200 p-8 rounded-xl border border-slate-300 shadow-inner flex flex-col items-center gap-6">
           {pages.map((_, i) => (
             <div key={i} className="relative shadow-xl transition-all duration-300">
               <span className="absolute -left-8 top-2 text-slate-500 font-bold text-xs">Pg {i+1}</span>
               <canvas ref={el => canvasRefs.current[i] = el} width={CANVAS_WIDTH} height={CANVAS_HEIGHT} className="bg-white shadow-lg" style={{ width: '420px', height: 'auto' }} />
             </div>
           ))}
        </div>
      </div>
    </div>
  );
};

export default App;
// ========================== v6.12 end =========================
// ========================== v8 start =========================
import React, { useState, useEffect, useRef } from 'react';
import jsPDF from 'jspdf';
import * as DOMPurify from 'dompurify';
import { Download, Bold, Underline, ScanLine, FileUp, Save, Image as ImageIcon, Table as TableIcon, Grid3X3, AlignJustify, Moon, Sun, Type, Plus, Trash2, Columns, Rows, ArrowRightFromLine, ArrowDownFromLine, ImageMinus } from 'lucide-react';

// --- CONFIGURATION ---
const SCALE = 2; 
const A4_WIDTH = 595;
const A4_HEIGHT = 842;
const CANVAS_WIDTH = A4_WIDTH * SCALE;
const CANVAS_HEIGHT = A4_HEIGHT * SCALE;
const MARGIN_X = 50 * SCALE;
const MARGIN_Y = 60 * SCALE;

// --- TYPES ---
type SegmentType = 'text' | 'image' | 'table';
type PaperType = 'lined' | 'grid' | 'blank';
type CellStyle = { 
    text: string; color: string; isBold: boolean; isUnderline: boolean; align: string;
    rowSpan: number; colSpan: number; 
};
type TableRow = { cells: (CellStyle | null)[]; maxHeight?: number }; 
type TableData = { rows: TableRow[]; colWidths: number[]; totalWidth: number };
type TextSegment = {
  type: SegmentType;
  text?: string; color?: string; isBold?: boolean; isUnderline?: boolean; width?: number;
  src?: string; height?: number;
  tableData?: TableData;
};
type PageData = { lines: TextSegment[][]; };
type ProjectFile = {
    version: string;
    htmlContent: string;
    settings: { skew: number; lineOpacity: number; scanEffect: boolean; fontSize: number; paperType: PaperType; }
};

const App = () => {
  // --- STATE ---
  const [pages, setPages] = useState<PageData[]>([]);
  const [skewFactor, setSkewFactor] = useState(1.5);
  const [scanEffect, setScanEffect] = useState(false);
  const [lineOpacity, setLineOpacity] = useState(0.4); 
  const [baseFontSize, setBaseFontSize] = useState(22);
  const [paperType, setPaperType] = useState<PaperType>('lined');
  const [isDarkMode, setIsDarkMode] = useState(false); 
  const [isProcessing, setIsProcessing] = useState(false);
  
  const editorRef = useRef<HTMLDivElement>(null);
  const canvasRefs = useRef<(HTMLCanvasElement | null)[]>([]);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const parseTimeoutRef = useRef<number | null>(null);

  const CURRENT_FONT_SIZE = baseFontSize * SCALE;
  const CURRENT_LINE_HEIGHT = CURRENT_FONT_SIZE * 1.5;
  const FONT_STACK = "'Segoe Script', 'Caveat', cursive";

  // --- EDITOR COMMANDS ---
  const applyFormat = (command: string, value?: string) => {
    document.execCommand(command, false, value);
    editorRef.current?.focus();
    triggerParse(); 
  };

  // --- HELPER: Build Virtual Grid for Accurate Merging ---
  const getTableGrid = (table: HTMLTableElement) => {
      const grid: { cell: HTMLTableCellElement, isOrigin: boolean }[][] = [];
      for (let r = 0; r < table.rows.length; r++) grid[r] = [];

      for (let r = 0; r < table.rows.length; r++) {
          const row = table.rows[r];
          let cIdx = 0;
          for (let c = 0; c < row.cells.length; c++) {
              // Skip slots already occupied by rowspans from above
              while (grid[r][cIdx]) cIdx++;
              
              const cell = row.cells[c];
              const rs = cell.rowSpan || 1;
              const cs = cell.colSpan || 1;

              for (let i = 0; i < rs; i++) {
                  for (let j = 0; j < cs; j++) {
                      if (!grid[r + i]) grid[r + i] = [];
                      grid[r + i][cIdx + j] = { cell, isOrigin: i === 0 && j === 0 };
                  }
              }
              cIdx += cs;
          }
      }
      return grid;
  };

  const modifyTable = (action: 'addRow' | 'delRow' | 'addCol' | 'delCol' | 'mergeRight' | 'mergeDown') => {
      const sel = window.getSelection();
      let cellNode = sel?.anchorNode;
      while (cellNode && cellNode !== editorRef.current && cellNode.nodeName !== 'TD' && cellNode.nodeName !== 'TH') {
          cellNode = cellNode.parentNode;
      }
      if (!cellNode || (cellNode.nodeName !== 'TD' && cellNode.nodeName !== 'TH')) {
          alert("Click inside a table cell first!");
          return;
      }

      const currentCell = cellNode as HTMLTableCellElement;
      const row = currentCell.parentElement as HTMLTableRowElement;
      const table = row.parentElement?.parentElement as HTMLTableElement;

      if (!table) return;

      // Use Grid System for Complex Operations
      const grid = getTableGrid(table);
      
      // Find coordinates of current cell
      let rIdx = -1, cIdx = -1;
      for(let r=0; r<grid.length; r++) {
          for(let c=0; c<grid[r].length; c++) {
              if (grid[r][c] && grid[r][c].cell === currentCell && grid[r][c].isOrigin) {
                  rIdx = r; cIdx = c; break;
              }
          }
          if (rIdx !== -1) break;
      }

      if (action === 'addRow') {
          const newRow = table.insertRow(row.rowIndex + 1);
          // Insert cells matching the visual columns (simplified, adds 1 per column)
          // A robust impl would check colspans, but for basic usage:
          const colCount = grid[0].length;
          for(let i=0; i<colCount; i++) {
              const newCell = newRow.insertCell();
              newCell.style.border = "1px solid #000";
              newCell.innerHTML = "New";
          }
      } 
      else if (action === 'delRow') {
          if (table.rows.length > 1) table.deleteRow(row.rowIndex);
      }
      else if (action === 'addCol') {
          // Add cell to every row
          for(let r=0; r<table.rows.length; r++) {
             const tr = table.rows[r];
             const newCell = tr.insertCell();
             newCell.style.border = "1px solid #000";
             newCell.innerHTML = "New";
          }
      }
      else if (action === 'delCol') {
          // Deleting columns in complex rowspan tables is very hard. 
          // Simple fallback: delete the cell at this visual index in every row
           alert("Column deletion in complex tables is restricted to simple layouts.");
      }
      else if (action === 'mergeRight') {
          // Find neighbor in grid
          const cellSpan = currentCell.colSpan || 1;
          const neighborX = cIdx + cellSpan;
          
          if (neighborX < grid[rIdx].length) {
              const neighborData = grid[rIdx][neighborX];
              if (neighborData && neighborData.isOrigin) {
                  const neighbor = neighborData.cell;
                  // Check if heights match (essential for rect merge)
                  if ((currentCell.rowSpan || 1) === (neighbor.rowSpan || 1)) {
                      currentCell.colSpan = (currentCell.colSpan || 1) + (neighbor.colSpan || 1);
                      currentCell.innerHTML += " " + neighbor.innerHTML;
                      neighbor.remove();
                  } else {
                      alert("Cannot merge cells of different heights.");
                  }
              }
          }
      }
      else if (action === 'mergeDown') {
          // FIX: Use Grid to find exact cell below
          const cellSpan = currentCell.rowSpan || 1;
          const neighborY = rIdx + cellSpan;

          if (neighborY < grid.length) {
              const neighborData = grid[neighborY][cIdx];
              if (neighborData && neighborData.isOrigin) {
                  const neighbor = neighborData.cell;
                  // Check if widths match
                  if ((currentCell.colSpan || 1) === (neighbor.colSpan || 1)) {
                      currentCell.rowSpan = (currentCell.rowSpan || 1) + (neighbor.rowSpan || 1);
                      currentCell.innerHTML += "<br/>" + neighbor.innerHTML;
                      neighbor.remove();
                  } else {
                      alert("Cannot merge cells of different widths.");
                  }
              }
          }
      }
      triggerParse();
  };

  const deleteSelectedImage = () => {
      const sel = window.getSelection();
      if (!sel?.rangeCount) return;
      
      const node = sel.anchorNode;
      // Check if image is selected directly (rare in contentEditable) or cursor is near
      // Easier: Let user click the image to select it (browser handles resizing handles), then click button
      // But browsers vary. 
      // Robust approach: Check if we are inside a figure or just remove current block?
      // Actually, standard `execCommand('delete')` works if image is "selected".
      document.execCommand('delete');
      triggerParse();
  };

  const insertImage = (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
          const result = event.target?.result as string;
          const sel = window.getSelection();
          if (sel && sel.rangeCount > 0) {
              const range = sel.getRangeAt(0);
              const img = document.createElement('img');
              img.src = result;
              img.style.maxWidth = "300px";
              img.style.display = "block";
              img.style.margin = "10px 0";
              range.deleteContents();
              range.insertNode(img);
              range.collapse(false); 
          } else {
              if (editorRef.current) editorRef.current.innerHTML += `<img src="${result}" style="max-width:300px; display:block; margin:10px 0;">`;
          }
          triggerParse();
      };
      reader.readAsDataURL(file);
      e.target.value = '';
  };

  const insertTable = () => {
      const tableHTML = `
        <table style="border-collapse: collapse; width: 100%; margin: 10px 0; border: 1px solid #000;">
            <tbody>
                <tr><td style="border: 1px solid #000; padding: 5px;">Head 1</td><td style="border: 1px solid #000; padding: 5px;">Head 2</td></tr>
                <tr><td style="border: 1px solid #000; padding: 5px;">Cell 1</td><td style="border: 1px solid #000; padding: 5px;">Cell 2</td></tr>
            </tbody>
        </table><p><br></p>
      `;
      document.execCommand('insertHTML', false, tableHTML);
      triggerParse();
  };

  // --- PARSER ---
  const triggerParse = () => {
    if (!editorRef.current) return;
    setIsProcessing(true);
    if (parseTimeoutRef.current) window.clearTimeout(parseTimeoutRef.current);
    parseTimeoutRef.current = window.setTimeout(() => {
      parseContentToPages(editorRef.current!);
      setIsProcessing(false);
      parseTimeoutRef.current = null;
    }, 300);
  };

  useEffect(() => {
    return () => { if (parseTimeoutRef.current) window.clearTimeout(parseTimeoutRef.current); };
  }, []);

  const parseContentToPages = (root: HTMLElement) => {
    const ctx = document.createElement('canvas').getContext('2d')!;
    const segments: TextSegment[] = [];
    
    // --- TABLE PROCESSOR v8.1 (Grid-Aware) ---
    const processTable = (tableEl: HTMLElement): TextSegment | null => {
        const rows = Array.from(tableEl.querySelectorAll('tr'));
        if (rows.length === 0) return null;

        // 1. Build Grid (Handle Rowspan/Colspan)
        const grid: (HTMLTableCellElement | null)[][] = [];
        const cellMap = new Map<HTMLTableCellElement, {r:number, c:number}>();
        for(let r=0; r<rows.length; r++) grid[r] = [];

        rows.forEach((tr, rIdx) => {
            const cells = Array.from(tr.querySelectorAll('td, th'));
            let cIdx = 0;
            cells.forEach((cell) => {
                while (grid[rIdx][cIdx]) cIdx++;
                const el = cell as HTMLTableCellElement;
                const rs = el.rowSpan || 1;
                const cs = el.colSpan || 1;
                for(let r = 0; r < rs; r++) {
                    for(let c = 0; c < cs; c++) {
                        if (grid[rIdx + r]) grid[rIdx + r][cIdx + c] = (r===0 && c===0) ? el : null; 
                    }
                }
                cellMap.set(el, {r: rIdx, c: cIdx}); 
                cIdx += cs;
            });
        });

        const maxCols = grid.reduce((max, row) => Math.max(max, row.length), 0);
        const colWidthsRaw = new Array(maxCols).fill(0);

        cellMap.forEach((pos, el) => {
             let text = el.innerText.trim();
             const isBold = el.tagName === 'TH' || el.style.fontWeight === 'bold';
             ctx.font = `${isBold ? 'bold' : 'normal'} ${CURRENT_FONT_SIZE}px ${FONT_STACK}`;
             const w = ctx.measureText(text).width + (20 * SCALE);
             if (w > colWidthsRaw[pos.c]) colWidthsRaw[pos.c] = w;
        });

        const MAX_TABLE_WIDTH = CANVAS_WIDTH - (MARGIN_X * 2);
        const totalMeasuredWidth = colWidthsRaw.reduce((a, b) => a + b, 0);
        const finalColWidths = [...colWidthsRaw];
        if (totalMeasuredWidth > MAX_TABLE_WIDTH) {
            const ratio = MAX_TABLE_WIDTH / totalMeasuredWidth;
            for(let i=0; i<finalColWidths.length; i++) finalColWidths[i] *= ratio;
        }

        const tableRows: TableRow[] = [];
        for (let r = 0; r < rows.length; r++) {
            const rowData: (CellStyle | null)[] = [];
            for (let c = 0; c < maxCols; c++) {
                const el = grid[r][c];
                if (el) {
                    const clone = el.cloneNode(true) as HTMLElement;
                    clone.querySelectorAll('li').forEach(li => { li.prepend("• "); li.append("\n"); });
                    
                    let finalColor = el.style.color || el.getAttribute('color');
                    if (!finalColor) {
                        const sChild = el.querySelector('[color], [style*="color"]');
                        if (sChild) finalColor = sChild.getAttribute('color') || (sChild as HTMLElement).style.color;
                    }
                    const isBold = el.tagName === 'TH' || el.style.fontWeight === 'bold' || !!el.querySelector('b, strong');
                    const isUnderline = el.tagName === 'U' || el.style.textDecoration === 'underline' || !!el.querySelector('u');

                    rowData.push({
                        text: clone.innerText.trim(),
                        color: finalColor || '#000000',
                        isBold: !!isBold,
                        isUnderline: !!isUnderline,
                        align: el.style.textAlign || 'left',
                        rowSpan: el.rowSpan || 1,
                        colSpan: el.colSpan || 1
                    });
                } else {
                    rowData.push(null);
                }
            }
            tableRows.push({ cells: rowData, maxHeight: CURRENT_LINE_HEIGHT * 1.2 });
        }

        return { type: 'table', tableData: { rows: tableRows, colWidths: finalColWidths, totalWidth: finalColWidths.reduce((a, b) => a + b, 0) } };
    };

    // Traversal
    const traverse = (node: Node, style: { color: string, isBold: boolean, isUnderline: boolean }, listContext: { type: string, index: number } | null) => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        const el = node as HTMLElement;
        const tagName = el.tagName;

        if (tagName === 'TABLE') {
            const tableSeg = processTable(el);
            if (tableSeg) segments.push(tableSeg);
            return; 
        }
        if (tagName === 'IMG') {
            const imgEl = el as HTMLImageElement;
            segments.push({ type: 'image', src: imgEl.src, width: imgEl.width * SCALE || 200 * SCALE, height: imgEl.height * SCALE || 150 * SCALE });
            return;
        }

        const isBlock = ['DIV', 'P', 'BR', 'LI', 'H1', 'H2', 'TR'].includes(tagName);
        let newListContext = listContext;
        if (tagName === 'UL') newListContext = { type: 'ul', index: 0 };
        if (tagName === 'OL') newListContext = { type: 'ol', index: 1 };
        
        let newColor = el.style.color || el.getAttribute('color') || style.color;
        const newBold = (tagName === 'B' || tagName === 'STRONG' || tagName === 'TH' || parseInt(el.style.fontWeight) > 600) || style.isBold;
        const newUnderline = (tagName === 'U' || el.style.textDecoration === 'underline') || style.isUnderline;

        if (tagName === 'LI' && listContext) {
            const bullet = listContext.type === 'ul' ? "• " : `${listContext.index}. `;
            segments.push({ type: 'text', text: bullet, color: newColor, isBold: true }); 
            if (listContext.type === 'ol') listContext.index++;
        }

        node.childNodes.forEach(child => traverse(child, { color: newColor, isBold: newBold, isUnderline: newUnderline }, newListContext));
        
        if (isBlock && tagName !== 'BR') {
           const lastSeg = segments[segments.length - 1];
           if (lastSeg && lastSeg.text !== '\n') segments.push({ type: 'text', text: '\n' });
        }
        if (tagName === 'BR') segments.push({ type: 'text', text: '\n' });

      } else if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent || "";
        if (text) segments.push({ type: 'text', text, color: style.color, isBold: style.isBold, isUnderline: style.isUnderline });
      }
    };

    traverse(root, { color: '#000000', isBold: false, isUnderline: false }, null);

    // Pagination
    const finalPages: PageData[] = [];
    let currentLines: TextSegment[][] = [];
    let currentLine: TextSegment[] = [];
    let currentY = MARGIN_Y;
    let currentX = MARGIN_X;
    
    const flushLine = (forceHeight?: number) => {
        currentLines.push(currentLine);
        currentLine = [];
        currentX = MARGIN_X;
        currentY += forceHeight ? forceHeight + 10 : CURRENT_LINE_HEIGHT; 
        if (currentY > CANVAS_HEIGHT - MARGIN_Y) {
            finalPages.push({ lines: currentLines });
            currentLines = [];
            currentY = MARGIN_Y;
        }
    };

    segments.forEach(seg => {
      if (seg.text === '\n') { flushLine(); return; }

      if (seg.type === 'table' || seg.type === 'image') {
          if (currentLine.length > 0) flushLine();
          const height = seg.type === 'table' ? (seg.tableData!.rows.length * (CURRENT_LINE_HEIGHT * 1.2)) + 20 : seg.height! + 20;
          if (currentY + height > CANVAS_HEIGHT - MARGIN_Y) {
             finalPages.push({ lines: currentLines });
             currentLines = [];
             currentY = MARGIN_Y;
          }
          currentLines.push([seg]); 
          currentY += height;
          return;
      }

      if (seg.type === 'text') {
        const words = seg.text!.split(/(\s+)/); 
        words.forEach(word => {
            if (word === "") return;
            ctx.font = `${seg.isBold ? 'bold' : 'normal'} ${CURRENT_FONT_SIZE}px ${FONT_STACK}`;
            const wordWidth = ctx.measureText(word).width;
            if (currentX + wordWidth > CANVAS_WIDTH - MARGIN_X) flushLine();
            currentLine.push({ ...seg, text: word, width: wordWidth });
            currentX += wordWidth;
        });
      }
    });

    if (currentLine.length > 0) flushLine();
    if (currentLines.length > 0) finalPages.push({ lines: currentLines });
    setPages(finalPages);
  };

  // --- RENDERER ---
  useEffect(() => {
    pages.forEach((pageData, index) => {
      const canvas = canvasRefs.current[index];
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      const mulberry32 = (seed: number) => {
        return () => {
          let t = seed += 0x6D2B79F5;
          t = Math.imul(t ^ (t >>> 15), t | 1);
          t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      };
      const rng = mulberry32(index + baseFontSize + Math.floor(skewFactor * 100));

      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      ctx.fillStyle = scanEffect ? "#f4f4f4" : "#fffdf0";
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      if (lineOpacity > 0) {
          ctx.strokeStyle = `rgba(100, 149, 237, ${lineOpacity})`; 
          ctx.lineWidth = 1 * SCALE;
          if (paperType === 'grid') {
            ctx.lineWidth = 0.5 * SCALE;
            const gridSize = 25 * SCALE;
            for (let x = MARGIN_X; x < CANVAS_WIDTH; x += gridSize) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, CANVAS_HEIGHT); ctx.stroke(); }
            for (let y = 0; y < CANVAS_HEIGHT; y += gridSize) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(CANVAS_WIDTH, y); ctx.stroke(); }
          } else if (paperType === 'lined') {
            for (let y = MARGIN_Y; y < CANVAS_HEIGHT; y += CURRENT_LINE_HEIGHT) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.bezierCurveTo(CANVAS_WIDTH/2, y + (scanEffect ? 2 : 0), CANVAS_WIDTH, y, CANVAS_WIDTH, y); ctx.stroke();
            }
            ctx.strokeStyle = `rgba(255, 100, 100, ${lineOpacity})`; ctx.beginPath(); ctx.moveTo(MARGIN_X - (15*SCALE), 0); ctx.lineTo(MARGIN_X - (15*SCALE), CANVAS_HEIGHT); ctx.stroke();
          }
      }

      let cursorY = MARGIN_Y;
      pageData.lines.forEach(line => {
        let cursorX = MARGIN_X;
        let maxLineHeight = CURRENT_LINE_HEIGHT;

        line.forEach(seg => {
           if (seg.type === 'image' && seg.src) {
               const img = new Image();
               img.crossOrigin = 'anonymous';
               const drawW = seg.width || (150 * SCALE);
               const drawH = seg.height || (100 * SCALE);
               img.onload = () => {
                 ctx.drawImage(img, cursorX, cursorY, drawW, drawH);
                 ctx.fillStyle = "rgba(255,255,255,0.6)";
                 ctx.fillRect(cursorX - 5, cursorY - 5, 30, 10);
                 ctx.fillRect(cursorX + drawW - 25, cursorY - 5, 30, 10);
               };
               img.src = seg.src;
               maxLineHeight = drawH + 20;
           } 
           else if (seg.type === 'table' && seg.tableData) {
               const { rows, colWidths } = seg.tableData;
               let tableY = cursorY;
               rows.forEach((row, rIdx) => {
                   let tableX = cursorX;
                   const rowHeight = row.maxHeight || CURRENT_LINE_HEIGHT;
                   row.cells.forEach((cell, cIdx) => {
                       const cellWidth = colWidths[cIdx];
                       if (cell) {
                           let fullWidth = cellWidth;
                           if (cell.colSpan > 1) {
                               for(let k=1; k<cell.colSpan; k++) fullWidth += colWidths[cIdx+k];
                           }
                           let fullHeight = rowHeight;
                           if (cell.rowSpan > 1) fullHeight = rowHeight * cell.rowSpan;

                           ctx.beginPath(); ctx.strokeStyle = "#444"; ctx.lineWidth = 1.5;
                           ctx.rect(tableX, tableY, fullWidth, fullHeight);
                           ctx.stroke();

                           ctx.font = `${cell.isBold ? 'bold' : 'normal'} ${CURRENT_FONT_SIZE}px ${FONT_STACK}`;
                           ctx.fillStyle = cell.color;
                           const rY = (rng() - 0.5) * (skewFactor * SCALE);
                           ctx.fillText(cell.text, tableX + (10*SCALE), tableY + (rowHeight*0.6) + rY);
                           
                           if (cell.isUnderline) {
                               ctx.beginPath(); ctx.strokeStyle = cell.color; ctx.lineWidth = 1.5;
                               const textWidth = ctx.measureText(cell.text).width;
                               ctx.moveTo(tableX + (10*SCALE), tableY + (rowHeight*0.6) + 5);
                               ctx.lineTo(tableX + (10*SCALE) + textWidth, tableY + (rowHeight*0.6) + 5 + (rng()*2));
                               ctx.stroke();
                           }
                       }
                       tableX += cellWidth;
                   });
                   tableY += rowHeight;
               });
               maxLineHeight = (tableY - cursorY) + 20;
           }
           else if (seg.type === 'text' && seg.text) {
              ctx.font = `${seg.isBold ? 'bold' : 'normal'} ${CURRENT_FONT_SIZE}px ${FONT_STACK}`;
              ctx.fillStyle = seg.color || '#000';
              for (let i = 0; i < seg.text.length; i++) {
                const char = seg.text[i];
                const charWidth = ctx.measureText(char).width;
                const rY = (rng() - 0.5) * (skewFactor * SCALE);
                const rRot = (rng() - 0.5) * (skewFactor * 0.15);
                ctx.save(); ctx.translate(cursorX + charWidth/2, cursorY + rY); ctx.rotate(rRot); ctx.fillText(char, -charWidth/2, 0); ctx.restore();
                if (seg.isUnderline) {
                    ctx.beginPath(); ctx.strokeStyle = seg.color || '#000'; ctx.lineWidth = 1.5;
                    ctx.moveTo(cursorX, cursorY + 5); ctx.lineTo(cursorX + charWidth, cursorY + 5 + (rng()*2)); ctx.stroke();
                }
                cursorX += charWidth;
              }
           }
        });
        cursorY += maxLineHeight;
      });

      if (scanEffect) {
          const grad = ctx.createLinearGradient(0, 0, 100 * SCALE, 0);
          grad.addColorStop(0, "rgba(0,0,0,0.12)");
          grad.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grad;
          ctx.fillRect(0,0, 100 * SCALE, CANVAS_HEIGHT);
      }
    });
  }, [pages, skewFactor, lineOpacity, scanEffect, baseFontSize, paperType]);

  const saveProject = () => {
      const project: ProjectFile = {
          version: '8.1',
          htmlContent: editorRef.current?.innerHTML || '',
          settings: { skew: skewFactor, lineOpacity, scanEffect, fontSize: baseFontSize, paperType }
      };
      const blob = new Blob([JSON.stringify(project)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'assignment.azm';
      a.click();
  };

  const loadProject = (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
          try {
              const project = JSON.parse(event.target?.result as string) as ProjectFile;
              if (editorRef.current) editorRef.current.innerHTML = DOMPurify.sanitize(project.htmlContent);
              setSkewFactor(project.settings.skew); setLineOpacity(project.settings.lineOpacity);
              setScanEffect(project.settings.scanEffect); setBaseFontSize(project.settings.fontSize || 22);
              setPaperType(project.settings.paperType || 'lined'); triggerParse();
          } catch (err) { alert("Invalid file"); }
      };
      reader.readAsText(file);
  };

  const downloadPDF = () => {
    const doc = new jsPDF('p', 'pt', [A4_WIDTH, A4_HEIGHT]);
    pages.forEach((_, i) => {
      const canvas = canvasRefs.current[i];
      if (canvas) {
        if (i > 0) doc.addPage();
        doc.addImage(canvas.toDataURL('image/jpeg', 0.8), 'JPEG', 0, 0, A4_WIDTH, A4_HEIGHT); 
      }
    });
    doc.save('assignment.pdf');
  };

  useEffect(() => {
    setTimeout(() => {
        if (editorRef.current) {
            editorRef.current.innerHTML = `<h3>Homework</h3><p>Data Table:</p>
            <table style="width: 100%; border-collapse: collapse; border: 1px solid black;">
                <tr><th style="border: 1px solid black; padding: 5px;">Item</th><th style="border: 1px solid black; padding: 5px;">Cost</th></tr>
                <tr><td style="border: 1px solid black; padding: 5px;">Apple</td><td style="border: 1px solid black; padding: 5px;">$1.50</td></tr>
            </table>`;
            triggerParse();
        }
    }, 100);
  }, []);

  const sliderStyle = `
    input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #3b82f6; border: 2px solid white; cursor: pointer; margin-top: -6px; box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
    input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #cbd5e1; border-radius: 2px; }
  `;

  return (
    <div className={`min-h-screen flex flex-col items-center font-sans transition-colors duration-300 ${isDarkMode ? 'bg-slate-900 text-slate-100' : 'bg-neutral-100 text-slate-800'}`}>
      <style>{sliderStyle}</style>
      <header className={`sticky top-0 z-50 w-full px-6 py-4 transition-colors duration-300 ${isDarkMode ? 'bg-slate-900/90 border-slate-700' : 'bg-white/90 border-slate-200'} backdrop-blur-md border-b flex justify-between items-center shadow-sm`}>
        <div className="max-w-6xl w-full mx-auto flex justify-between items-center">
            <h1 className="text-2xl font-bold flex items-center gap-2">
               <span className="text-blue-600 text-3xl">✍️</span> AssignmentMaker 
               <span className={`text-xs px-2 py-1 rounded ${isDarkMode ? 'bg-purple-900 text-purple-200' : 'bg-purple-100 text-purple-800'}`}>v8.1</span>
               {isProcessing && <span className="text-xs text-blue-500 animate-pulse ml-2">Processing...</span>}
            </h1>
            <div className="flex gap-3">
                <button onClick={() => setIsDarkMode(!isDarkMode)} className={`p-2 rounded-full transition-colors ${isDarkMode ? 'bg-slate-800 hover:bg-slate-700' : 'bg-slate-100 hover:bg-slate-200'}`}>{isDarkMode ? <Sun size={20} className="text-yellow-400"/> : <Moon size={20} className="text-slate-600"/>}</button>
                <div className="w-px h-8 bg-slate-300 mx-2 opacity-50"></div>
                <button onClick={() => fileInputRef.current?.click()} className={`px-4 py-2 rounded-lg text-sm font-medium flex items-center gap-2 transition-colors ${isDarkMode ? 'bg-slate-800 hover:bg-slate-700 border-slate-700' : 'bg-white hover:bg-slate-50 border border-slate-200'}`}><FileUp size={16}/> Import</button>
                <input type="file" ref={fileInputRef} onChange={loadProject} accept=".azm,.json" className="hidden" />
                <button onClick={saveProject} className={`px-4 py-2 rounded-lg text-sm font-medium flex items-center gap-2 transition-colors ${isDarkMode ? 'bg-slate-800 hover:bg-slate-700 border-slate-700' : 'bg-white hover:bg-slate-50 border border-slate-200'}`}><Save size={16}/> Save</button>
                <button onClick={downloadPDF} className="bg-blue-600 hover:bg-blue-700 text-white px-5 py-2 rounded-lg shadow-md text-sm font-medium flex gap-2 items-center transition-transform hover:scale-105"><Download size={16}/> Export PDF</button>
            </div>
        </div>
      </header>

      <div className="w-full max-w-6xl flex gap-8 py-8 h-[calc(100vh-80px)]">
        <div className={`w-1/2 flex flex-col rounded-xl shadow-xl border overflow-hidden transition-colors ${isDarkMode ? 'bg-slate-800 border-slate-700' : 'bg-white border-slate-200'}`}>
          <div className={`p-4 border-b transition-colors ${isDarkMode ? 'bg-slate-800 border-slate-700' : 'bg-slate-50 border-slate-100'} flex flex-col gap-4`}>
             <div className="flex justify-between items-center">
                 <div className="flex gap-2 items-center">
                    <div className={`flex rounded-md overflow-hidden border ${isDarkMode ? 'border-slate-600' : 'border-slate-300'}`}>
                        {['#000000', '#000f55', '#cc0000', '#1a5c20'].map(c => ( <button key={c} onClick={() => applyFormat('foreColor', c)} className="w-8 h-8 hover:opacity-80 transition-opacity" style={{backgroundColor: c}} title="Ink Color" /> ))}
                    </div>
                    <div className={`w-px h-6 mx-1 ${isDarkMode ? 'bg-slate-600' : 'bg-slate-300'}`}></div>
                    <button onClick={() => applyFormat('bold')} className={`p-2 rounded hover:bg-opacity-20 hover:bg-slate-500 ${isDarkMode ? 'text-slate-300' : 'text-slate-700'}`} title="Bold"><Bold size={18}/></button>
                    <button onClick={() => applyFormat('underline')} className={`p-2 rounded hover:bg-opacity-20 hover:bg-slate-500 ${isDarkMode ? 'text-slate-300' : 'text-slate-700'}`} title="Underline"><Underline size={18}/></button>
                 </div>
                 <div className="flex gap-2 items-center">
                    <button onClick={() => applyFormat('insertUnorderedList')} className={`px-3 py-1 rounded font-bold border hover:bg-opacity-10 ${isDarkMode ? 'border-slate-600 text-slate-300 hover:bg-white' : 'border-slate-200 text-slate-700 hover:bg-black'}`}>• Bullet</button>
                    <button onClick={() => applyFormat('insertOrderedList')} className={`px-3 py-1 rounded font-bold border hover:bg-opacity-10 ${isDarkMode ? 'border-slate-600 text-slate-300 hover:bg-white' : 'border-slate-200 text-slate-700 hover:bg-black'}`}>1. List</button>
                    <button onClick={deleteSelectedImage} className={`p-2 rounded border hover:bg-red-100 text-red-500 ${isDarkMode ? 'border-slate-600 hover:bg-red-900' : 'border-slate-200'}`} title="Delete Selected Image"><ImageMinus size={18}/></button>
                    <label className={`p-2 rounded border cursor-pointer hover:bg-opacity-10 ${isDarkMode ? 'border-slate-600 text-slate-300 hover:bg-white' : 'border-slate-200 text-slate-700 hover:bg-black'}`} title="Insert Image"><ImageIcon size={18}/><input type="file" onChange={insertImage} className="hidden"/></label>
                 </div>
             </div>

             <div className="flex items-center gap-2 p-2 rounded-lg bg-blue-50/50 border border-blue-100 flex-wrap">
                <span className="text-xs font-bold text-blue-800 px-2">Table:</span>
                <button onClick={insertTable} className="p-1.5 rounded hover:bg-blue-100 text-blue-800" title="New Table"><TableIcon size={16}/></button>
                <div className="w-px h-4 bg-blue-200"></div>
                <button onClick={() => modifyTable('addRow')} className="p-1.5 rounded hover:bg-blue-100 text-blue-800 flex gap-1 text-xs items-center" title="Add Row"><Rows size={14}/><Plus size={10}/></button>
                <button onClick={() => modifyTable('delRow')} className="p-1.5 rounded hover:bg-red-100 text-red-600 flex gap-1 text-xs items-center" title="Delete Row"><Rows size={14}/><Trash2 size={10}/></button>
                <div className="w-px h-4 bg-blue-200"></div>
                <button onClick={() => modifyTable('addCol')} className="p-1.5 rounded hover:bg-blue-100 text-blue-800 flex gap-1 text-xs items-center" title="Add Col"><Columns size={14}/><Plus size={10}/></button>
                <button onClick={() => modifyTable('delCol')} className="p-1.5 rounded hover:bg-red-100 text-red-600 flex gap-1 text-xs items-center" title="Delete Col"><Columns size={14}/><Trash2 size={10}/></button>
                <div className="w-px h-4 bg-blue-200"></div>
                <button onClick={() => modifyTable('mergeRight')} className="p-1.5 rounded hover:bg-purple-100 text-purple-800 flex gap-1 text-xs items-center" title="Merge Right"><ArrowRightFromLine size={14}/></button>
                <button onClick={() => modifyTable('mergeDown')} className="p-1.5 rounded hover:bg-purple-100 text-purple-800 flex gap-1 text-xs items-center" title="Merge Down"><ArrowDownFromLine size={14}/></button>
             </div>

             <div className="grid grid-cols-2 gap-6 pt-2">
                <div className="space-y-3">
                    <div className="flex justify-between text-xs font-semibold uppercase tracking-wider opacity-70"><span>Messiness</span> <span>{skewFactor}</span></div>
                    <input type="range" min="0" max="3" step="0.5" value={skewFactor} onChange={(e) => setSkewFactor(parseFloat(e.target.value))} />
                    <div className="flex justify-between text-xs font-semibold uppercase tracking-wider opacity-70 mt-1"><span>Font Size</span> <span>{baseFontSize}px</span></div>
                    <input type="range" min="14" max="32" step="1" value={baseFontSize} onChange={(e) => setBaseFontSize(parseInt(e.target.value))} />
                </div>
                <div className="space-y-3">
                     <div className="flex justify-between text-xs font-semibold uppercase tracking-wider opacity-70"><span>Paper Lines</span> <span>{Math.round(lineOpacity * 100)}%</span></div>
                    <input type="range" min="0" max="1" step="0.1" value={lineOpacity} onChange={(e) => setLineOpacity(parseFloat(e.target.value))} />
                    <div className="flex gap-2 pt-1">
                        <button onClick={() => setPaperType(prev => prev === 'lined' ? 'grid' : prev === 'grid' ? 'blank' : 'lined')} className={`flex-1 py-1.5 rounded text-xs font-medium border flex items-center justify-center gap-2 transition-colors ${isDarkMode ? 'border-slate-600 hover:bg-slate-700' : 'border-slate-300 hover:bg-slate-100'}`}>
                             {paperType === 'lined' ? <><AlignJustify size={14}/> Lined</> : paperType === 'grid' ? <><Grid3X3 size={14}/> Grid</> : <><Type size={14}/> Blank</>}
                        </button>
                        <button onClick={() => setScanEffect(!scanEffect)} className={`flex-1 py-1.5 rounded text-xs font-medium border flex items-center justify-center gap-2 transition-colors ${scanEffect ? 'bg-blue-600 text-white border-blue-600' : (isDarkMode ? 'border-slate-600 hover:bg-slate-700' : 'border-slate-300 hover:bg-slate-100')}`}>
                             <ScanLine size={14}/> {scanEffect ? 'Scanner ON' : 'Scanner OFF'}
                        </button>
                    </div>
                </div>
             </div>
          </div>
          <div className="flex-grow bg-white text-slate-900 relative"><div ref={editorRef} contentEditable onInput={triggerParse} className="absolute inset-0 p-8 outline-none overflow-y-auto font-sans text-lg leading-relaxed"></div></div>
        </div>
        <div className={`w-1/2 overflow-y-auto rounded-xl shadow-inner border p-8 flex flex-col items-center gap-8 ${isDarkMode ? 'bg-slate-900/50 border-slate-700' : 'bg-slate-200 border-slate-300'}`}>
           {pages.map((_, i) => (
             <div key={i} className="relative group">
               <span className={`absolute -left-10 top-0 font-bold text-xs opacity-50 ${isDarkMode ? 'text-slate-400' : 'text-slate-600'}`}>Pg {i+1}</span>
               <canvas ref={el => canvasRefs.current[i] = el} width={CANVAS_WIDTH} height={CANVAS_HEIGHT} className="bg-white shadow-2xl rounded-sm transition-transform duration-300 hover:scale-[1.02]" style={{ width: '450px', height: 'auto' }} />
             </div>
           ))}
        </div>
      </div>
    </div>
  );
};

export default App;
// ========================== v8 end =========================